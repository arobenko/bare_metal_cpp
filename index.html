<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Alex Robenko">
<title>Practical Guide to Bare Metal C++</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Practical Guide to Bare Metal C++</h1>
<div class="details">
<span id="author" class="author">Alex Robenko</span><br>
<span id="revnumber">version 1.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">Overview</a>
<ul class="sectlevel2">
<li><a href="#_audience">Audience</a></li>
<li><a href="#_c_popularity">C&#43;&#43; Popularity</a></li>
<li><a href="#overview-benefits">Benefits of C&#43;&#43;</a></li>
<li><a href="#overview-contents">Contents of This Book</a></li>
<li><a href="#_contribution">Contribution</a></li>
</ul>
</li>
<li><a href="#_know_your_compiler_output">Know Your Compiler Output</a>
<ul class="sectlevel2">
<li><a href="#_test_applications">Test Applications</a></li>
<li><a href="#_get_simple_application_compiled">Get Simple Application Compiled</a></li>
<li><a href="#_dynamic_memory_allocation">Dynamic Memory Allocation</a></li>
<li><a href="#compiler_output-exceptions">Exceptions</a></li>
<li><a href="#_rtti">RTTI</a></li>
<li><a href="#compiler_output-nostdlib">Removing Standard Library and C&#43;&#43; Runtime</a></li>
<li><a href="#_static_objects">Static Objects</a></li>
<li><a href="#_abstract_classes">Abstract Classes</a></li>
<li><a href="#compiler_output-templates">Templates</a></li>
<li><a href="#_tag_dispatching">Tag Dispatching</a></li>
</ul>
</li>
<li><a href="#basic_needs-basic_needs">Basic Needs</a>
<ul class="sectlevel2">
<li><a href="#_assertion">Assertion</a></li>
<li><a href="#_callback">Callback</a></li>
<li><a href="#_data_serialisation">Data Serialisation</a></li>
<li><a href="#basic_needs-queue">Static (Fixed Size) Queue</a></li>
</ul>
</li>
<li><a href="#_basic_concepts">Basic Concepts</a>
<ul class="sectlevel2">
<li><a href="#basic_concepts-event_loop">Event Loop</a></li>
<li><a href="#basic_concepts-device_driver_component">Device-Driver-Component</a></li>
</ul>
</li>
<li><a href="#peripherals-peripherals">Peripherals</a>
<ul class="sectlevel2">
<li><a href="#_function_configuration">Function Configuration</a></li>
<li><a href="#_interrupts_management">Interrupts Management</a></li>
<li><a href="#_timer">Timer</a></li>
<li><a href="#peripherals-uart">UART</a></li>
<li><a href="#_gpio">GPIO</a></li>
<li><a href="#peripherals-i2c">I2C</a></li>
<li><a href="#peripherals-spi">SPI</a></li>
<li><a href="#_other">Other</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once in a while I encounter a question whether C&#43;&#43; is suitable for embedded development and
bare metal development in particular. There are multiple articles of how C&#43;&#43; is superior to C,
that everything you can do in C you can do in C&#43;&#43; with a lot of extras, and that it should
be used even with bare metal development. However, I haven&#8217;t found many practical guides or
tutorials of how to use C&#43;&#43; superiority and boost development process compared to conventional
approach of using “C” programming language. With this book I hope to explain and show examples
of how to implement <strong>soft</strong> real time systems without prioritising interrupts and without
any need for complex real time task scheduling. Hopefully it will help someone to get started
with using C&#43;&#43; in embedded bare metal development.</p>
</div>
<div class="paragraph">
<p>This work is licensed under a
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cc-by-nd.png" alt="cc by nd">
</div>
</div>
<div class="sect2">
<h3 id="_audience">Audience</h3>
<div class="paragraph">
<p>The primary intended audience of this document is professional C&#43;&#43; developers who want
to understand bare metal development a little bit better, get to know how to use their
favourite programming language in an embedded environment, and probably bring their C&#43;&#43;
skills to an “expert” level. Why <strong>professional</strong>? Because bare metal platform has lots
of limitations. In most cases no exceptions and no runtime type information (RTTI) support
will be available. In many cases the dynamic memory allocation will also be excluded.
In order to be able to use C&#43;&#43; effectively you will have to have deep knowledge of existing
C&#43;&#43; idioms, constructs and STL contents. You must know how your favourite data structures
are implemented and whether it is possible to reuse them in your environment. If  it is
not possible to use  the STL (or any other library) code “as is”, you will have to implement
a reduced version of it, and it is better to know how the library developers implemented
the feature and how to make it work with the constrains of your environment.</p>
</div>
<div class="paragraph">
<p>The professional embedded developers with intermediate knowledge of C&#43;&#43; may also find this
document useful. They will probably benefit from lots of C&#43;&#43; insights and will have several
“eureka” moments with “I didn&#8217;t know I could do that!!!” kind of thoughts.</p>
</div>
<div class="paragraph">
<p>If your C&#43;&#43; knowledge doesn&#8217;t go much beyond polymorphism and virtual functions, if
template meta-programming doesn&#8217;t mean anything to you, probably you are not ready to use
C&#43;&#43; in the embedded environment and this document will probably be too complex to understand.</p>
</div>
<div class="paragraph">
<p>I&#8217;d like to emphasise the fact that this is NOT a C&#43;&#43; tutorial. There are lots of resources on
the web that teach conventional C&#43;&#43; with OS services, exceptions and RTTI. My personal
opinion is that you have to master C&#43;&#43; in regular environment before using it effectively
in the bare metal world.</p>
</div>
</div>
<div class="sect2">
<h3 id="_c_popularity">C&#43;&#43; Popularity</h3>
<div class="paragraph">
<p>C&#43;&#43; is quite popular in the embedded world of Linux-based embedded systems. However, it is not
that popular in bare metal development. Why? Probably because of its complexity. Knowing C&#43;&#43;
syntax is not enough. To use it effectively the developer must know what Standard Template
Library (STL) provides, what can and what cannot be used when developing for specific platform.
STL mastery is also not enough, the developer should have some level of proficiency in
template meta-programming. Although there is an opinion that templates are dangerous because of
executable code bloating, I think that templates are developer&#8217;s friends, but the one must
know the dangers and know how to use templates effectively. But again, it requires time and effort
to get to know how to do it right.</p>
</div>
<div class="paragraph">
<p>Another reason why C&#43;&#43; is not used in bare metal development is that software in significant
number (if not majority) of projects gets written by hardware developers, at least in its first
stages just to make sure the hardware works as expected. The “C” programming language is a natural
choice for them. And of course majority of hardware developers lack proficiency in software development.
They may have some difficulties writing code of good quality in “C”, not to mention “C&#43;&#43;”. After
software reaches certain level of complexity it is handed over to software engineers who are not allowed
to re-implement it from scratch. They are told something like: “This code almost works, just fix a
couple of bugs, implement this short set of features and we&#8217;re good to go. Throwing away the existing
code is a waste, we do not have time to re-implement it.”</p>
</div>
<div class="paragraph">
<p>The last reason, I think, is psychological one. People prefer to be wrong in a group than right by
themselves. When majority of bare metal products being developed using “C”, it feels risky and
unnatural to choose “C&#43;&#43;”, even though the latter is better choice from the technological perspective.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-benefits">Benefits of C&#43;&#43;</h3>
<div class="paragraph">
<p>The primary reason to prefer C&#43;&#43; over C is <strong>code reuse</strong>. Thanks to templates,
it is much easier to implement generic piece of code that can be reused between
projects in C&#43;&#43; than in C. When implementing everything from scratch, then
probably using C&#43;&#43; instead of C won&#8217;t give any significant advantage in terms
of development effort, maybe even extend it. However, once generic components
have been developed, the whole development process for next projects will be
much easier and faster, thanks to reuse of the former.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-contents">Contents of This Book</h3>
<div class="paragraph">
<p>This document introduces several concepts that can be used in bare-metal development as well
as shows how they can be implemented using features of latest (at the time of writing)
C&#43;&#43;11 standard.</p>
</div>
<div class="paragraph">
<p>The code of generic components is implemented as part of  “Embedded C&#43;&#43; Library” project
called “embxx”  and can be found at <a href="https://github.com/arobenko/embxx" class="bare">https://github.com/arobenko/embxx</a>. It has GPLv3 licence.</p>
</div>
<div class="paragraph">
<p>There is also a project that implements multiple simple bare metal applications using
<a href="https://github.com/arobenko/embxx">embxx</a> which can run on RaspberryPi platform. The source
code can be found at  <a href="https://github.com/arobenko/embxx_on_rpi" class="bare">https://github.com/arobenko/embxx_on_rpi</a>. It also has GPLv3 licence.</p>
</div>
<div class="paragraph">
<p>Both projects require gcc version 4.7 or higher, because of C&#43;&#43;11 support requirement.
They also use <a href="http://www.cmake.org">CMake</a> as their build system. The code has been tested
with following free toolchains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://launchpad.net/gcc-arm-embedded">GNU Tools for ARM Embedded Processors</a> on Launchpad</p>
</li>
<li>
<p><a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/">Sourcery CodeBench Lite Edition</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The whole document is ARM platform centric. At this moment I do not try to cover anything else.</p>
</div>
<div class="paragraph">
<p>To compile Raspberry Pi example applications in Linux environment use the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checkout <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; git clone https://github.com/arobenko/embxx_on_rpi.git
&gt; cd embxx_on_rpi</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Create separate build directory and cd to it</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mkdir build
&gt; cd build</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Generate makefiles</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; cmake ..</pre>
</div>
</div>
<div class="paragraph">
<p>Note that last parameter to cmake is relative or absolute path to the root of the source tree.
Also note that <a href="https://github.com/arobenko/embxx">embxx</a> library will be checked out as external
git submodule during this process.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build the applications</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; make</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Take the generated image from <code>&lt;build_dir&gt;/image/&lt;app_name&gt;/kernel.img</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The CMake provides the following build types, which I believe are self-explanatory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>None (default)</p>
</li>
<li>
<p>Debug</p>
</li>
<li>
<p>Release</p>
</li>
<li>
<p>MinSizeRel</p>
</li>
<li>
<p>RelWithDebInfo</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To specify the required build type use <code>-DCMAKE_BUILD_TYPE=&lt;value&gt;</code> option of cmake utility:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; cmake -DCMAKE_BUILD_TYPE=Release ..</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no build type is specified, the default one is <strong>None</strong>, which is similar to <strong>Debug</strong>, but
without <code>-g</code> compilation option, i.e. no optimisations and no debugging information is generated.</p>
</div>
<div class="paragraph">
<p>It is possible to specify the cross-compilation toolchain prefix. By default <code>arm-none-eabi-</code>
is expected, i.e. <code>arm-none-eabi-gcc</code>, <code>arm-none-eabi-g++</code> and <code>arm-none-eabi-as</code> are used to
compile the sources. If these utilities cannot be found in environment search paths, then you
should specify the prefix passing <code>-DCROSS_COMPILE=&lt;prefix&gt;</code> option to cmake:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; cmake -DCROSS_COMPILE=/opt/arm-none-eabi-2013.05/bin/arm-none-eabi- ..</code></pre>
</div>
</div>
<div class="paragraph">
<p>To see the commands used to compile the sources, prefix <code>make</code> with <code>VERBOSE=1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; VERBOSE=1 make</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx">embxx</a> library has doxygen generated documentation. It can be found
at <a href="https://github.com/arobenko/embxx/releases">release artifacts</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contribution">Contribution</h3>
<div class="paragraph">
<p>If you have any suggestions, requests, bug fixes, spelling mistakes fixes, or maybe you
feel that some things are not explained properly, please feel free to e-mail me to <strong>arobenko@gmail.com</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_know_your_compiler_output">Know Your Compiler Output</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To successfully use C&#43;&#43; language and its libraries in bare metal development it is important
to know what binary code compiler generates from the C&#43;&#43; source code. This section will
lead you through the process of building simple testing applications and analysis of
their binary code.</p>
</div>
<div class="sect2">
<h3 id="_test_applications">Test Applications</h3>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project contains
several simple test application, which are intended to be used for binary code
analysis only and not to be executed on the target platform. This applications
reside in <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp">src/test_cpp</a>
directory. In order to properly analyse the code that compiler produces for production
environment, let&#8217;s compile all the applications in Release mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; git clone https://github.com/arobenko/embxx_on_rpi.git
&gt; mkdir -p &lt;build_dir_somewhere&gt;
&gt; cd &lt;build_dir_somewhere&gt;
&gt; cmake -DCMAKE_BUILD_TYPE=Release &lt;path/to/embxx_on_rpi&gt;
&gt; VERBOSE=1 make</code></pre>
</div>
</div>
<div class="paragraph">
<p>The listing file of every application will be <code>&lt;build_dir_somewhere&gt;/src/test_cpp/&lt;app_name&gt;/kernel.list</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_get_simple_application_compiled">Get Simple Application Compiled</h3>
<div class="paragraph">
<p>Let&#8217;s try to compile simple application of infinite loop, called
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple">test_cpp_simple</a>.</p>
</div>
<div class="paragraph">
<p>A linker script is required to get all the generated objects successfully linked. It states
what code/data sections need to be loaded at what addresses as well as defines several symbols
that may  be required by the sources. <a href="http://www.delorie.com/gnu/docs/binutils/ld_6.html">Here</a>
is a good manual of linker script syntax and
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/raspberrypi.ld">here</a> is the linker script
I use to get applications linked for Raspberry Pi platform.</p>
</div>
<div class="paragraph">
<p>Depending on your compiler, the link may fail because some symbols are missing. For example
<code>__exidx_start</code> and <code>__exidx_end</code> are needed when the application is compiled with exceptions
support, or <code>__bss_start__</code> and <code>__bss_end__</code> may be required by standard library if it contains
the code for zeroing <code>.bss</code> section.</p>
</div>
<div class="paragraph">
<p>Every application must have a startup code usually written in Assembler. This startup code must
perform the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write the interrupt vector table at appropriate location (usually at address 0x0000).</p>
</li>
<li>
<p>Set the stack pointers for every runtime mode.</p>
</li>
<li>
<p>Zero the .bss section</p>
</li>
<li>
<p>Call constructors of global (static) objects (applicable only to C&#43;&#43;)</p>
</li>
<li>
<p>Call the main function.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It may happen that compiler generates some startup code for you, especially if you haven&#8217;t
excluded standard library (stdlib) from compilation. To check whether this is the case,
we need to analyse assembler listing of the successfully compiled and linked image binary.
All the generated files for a test application will reside in <code>&lt;build_dir&gt;/src/test_cpp/&lt;app_name&gt;</code>.
The assembler listing file will have <code>kernel.list</code> name.</p>
</div>
<div class="paragraph">
<p><strong>Side note</strong>: the assembler listing can be generated using the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; arm-none-eabi-objdump -D -S app_binary &gt; app.list</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open the listing file and look for function with <strong>CRT</strong> string in it. <strong>CRT</strong>
stands for “C Run-Time”.  When using <a href="https://launchpad.net/gcc-arm-embedded">this</a>
compiler, the function that compiler has generated, is called <code>_mainCRTStartup</code>.
Let&#8217;s take closer look what this function does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008198 &lt;_mainCRTStartup&gt;:</code></pre>
</div>
</div>
<div class="paragraph">
<p>Load the address of the end of the RAM and assign its value to stack pointer (sp).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    8198:	e59f30f0 	ldr	r3, [pc, #240]	; 8290 &lt;_mainCRTStartup+0xf8&gt;
    819c:	e3530000 	cmp	r3, #0
    81a0:	059f30e4 	ldreq	r3, [pc, #228]	; 828c &lt;_mainCRTStartup+0xf4&gt;
    81a4:	e1a0d003 	mov	sp, r3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Set the value of sp for various modes, the sizes of the stacks are determined by the compiler itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    81a8:	e10f2000 	mrs	r2, CPSR
    81ac:	e312000f 	tst	r2, #15
    81b0:	0a000015 	beq	820c &lt;_mainCRTStartup+0x74&gt;
    81b4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    81b8:	e1a0d003 	mov	sp, r3
    81bc:	e24daa01 	sub	sl, sp, #4096	; 0x1000
    81c0:	e1a0300a 	mov	r3, sl
    81c4:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    81c8:	e1a0d003 	mov	sp, r3
    81cc:	e2433a01 	sub	r3, r3, #4096	; 0x1000
    81d0:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    81d4:	e1a0d003 	mov	sp, r3
    81d8:	e2433a01 	sub	r3, r3, #4096	; 0x1000
    81dc:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    81e0:	e1a0d003 	mov	sp, r3
    81e4:	e2433a02 	sub	r3, r3, #8192	; 0x2000
    81e8:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    81ec:	e1a0d003 	mov	sp, r3
    81f0:	e2433902 	sub	r3, r3, #32768	; 0x8000
    81f4:	e3c330ff 	bic	r3, r3, #255	; 0xff
    81f8:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
    81fc:	e5033004 	str	r3, [r3, #-4]
    8200:	e9532000 	ldmdb	r3, {sp}^
    8204:	e38220c0 	orr	r2, r2, #192	; 0xc0
    8208:	e121f002 	msr	CPSR_c, r2
    820c:	e243a801 	sub	sl, r3, #65536	; 0x10000
    8210:	e3b01000 	movs	r1, #0
    8214:	e1a0b001 	mov	fp, r1
    8218:	e1a07001 	mov	r7, r1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Load the addresses of <code>__bss_start__</code> and <code>__bss_end__</code> symbols and zero all the area in between.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    821c:	e59f0078 	ldr	r0, [pc, #120]	; 829c &lt;_mainCRTStartup+0x104&gt;
    8220:	e59f2078 	ldr	r2, [pc, #120]	; 82a0 &lt;_mainCRTStartup+0x108&gt;
    8224:	e0522000 	subs	r2, r2, r0
    8228:	eb00004a 	bl	8358 &lt;memset&gt;

   ... Then comes some code, purpose of which is not clear</code></pre>
</div>
</div>
<div class="paragraph">
<p>Call the <code>__libc_init_array</code> function provided by standard library which will initialise all the
global objects. It will treat the area between <code>__init_array_start</code> and <code>__init_array_end</code> as list
of pointers to initialisation functions and call them one by one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    8278:	eb000014 	bl	82d0 &lt;__libc_init_array&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Call the main function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    8284:	eb000010 	bl	82cc &lt;main&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>main</code> function returns for some reason, call the exit function, which probably must be implemented
as infinite loop or jumping  back to the beginning of the startup code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    8288:	eb000008 	bl	82b0 &lt;exit&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here comes local data</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    828c:	00080000 	andeq	r0, r8, r0
    8290:	04008000 	streq	r8, [r0], #-0
	...
    829c:	00008458 	andeq	r8, r0, r8, asr r4
    82a0:	00008474 	andeq	r8, r0, r4, ror r4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only missing stage in the startup process is updating the interrupt vector
table. After the latter is updated properly, it is possible to call the provided
<code>_mainCRTStartup</code> function. However, if your compiler doesn&#8217;t provide such
function you have no other choice but to write the whole startup code yourself.
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s">Here</a>
is an example of such code.</p>
</div>
<div class="paragraph">
<p>Please note, that <code>.bss</code> section by definition contains uninitialised data
that must be zeroed at startup. Even if you don&#8217;t have uninitialised variables
in your code, zeroing <code>.bss</code> is a must have operation. This is because compiler
might put variables that are explicitly initialised to 0 into the <code>.bss</code> for
performance reasons and count on this section being zeroed at startup.</p>
</div>
<div class="paragraph">
<p>Also note, that pointers to initialisation functions of global variables reside
in <code>.init.array</code> section. To initialise your global objects you just iterate
over all entries in this section and call them one by one.</p>
</div>
<div class="paragraph">
<p>To implement the missing stage for use the following assembler instructions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>_entry:
    ldr pc,reset_handler_ptr        ;@  Processor Reset handler
    ldr pc,undefined_handler_ptr    ;@  Undefined instruction handler
    ldr pc,swi_handler_ptr          ;@  Software interrupt
    ldr pc,prefetch_handler_ptr     ;@  Prefetch/abort handler.
    ldr pc,data_handler_ptr         ;@  Data abort handler/
    ldr pc,unused_handler_ptr       ;@
    ldr pc,irq_handler_ptr          ;@  IRQ handler
    ldr pc,fiq_handler_ptr          ;@  Fast interrupt handler.

    ;@ Set the branch addresses
    reset_handler_ptr:      .word reset
    undefined_handler_ptr:  .word hang
    swi_handler_ptr:        .word hang
    prefetch_handler_ptr:   .word hang
    data_handler_ptr:       .word hang
    unused_handler_ptr:     .word hang
    irq_handler_ptr:        .word irq_handler
    fiq_handler_ptr:        .word hang

reset:
    ;@ Disable interrupts
    cpsid if

    ;@ Copy interrupt vector to its place
    ldr r0,=_entry
    mov r1,#0x0000

    ;@  Here we copy the branching instructions
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}

    ;@  Here we copy the branching addresses
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that at interrupt vector table that resides at address 0x0000 contains branch
instructions to the appropriate handlers, not just addresses of the handlers. Let&#8217;s take a closer
look how these branching instructions look in our assembler listing file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>_entry:
    800c:	e59ff018 	ldr	pc, [pc, #24]	; 802c &lt;reset_handler_ptr&gt;
    8010:	e59ff018 	ldr	pc, [pc, #24]	; 8030 &lt;undefined_handler_ptr&gt;
    8014:	e59ff018 	ldr	pc, [pc, #24]	; 8034 &lt;swi_handler_ptr&gt;
    8018:	e59ff018 	ldr	pc, [pc, #24]	; 8038 &lt;prefetch_handler_ptr&gt;
    801c:	e59ff018 	ldr	pc, [pc, #24]	; 803c &lt;data_handler_ptr&gt;
    8020:	e59ff018 	ldr	pc, [pc, #24]	; 8040 &lt;unused_handler_ptr&gt;
    8024:	e59ff018 	ldr	pc, [pc, #24]	; 8044 &lt;irq_handler_ptr&gt;
    8028:	e59ff018 	ldr	pc, [pc, #24]	; 8048 &lt;fiq_handler_ptr&gt;

0000802c &lt;reset_handler_ptr&gt;:
    802c:	0000804c 	andeq	r8, r0, ip, asr #32

00008030 &lt;undefined_handler_ptr&gt;:
    8030:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4

00008034 &lt;swi_handler_ptr&gt;:
    8034:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4

00008038 &lt;prefetch_handler_ptr&gt;:
    8038:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4

0000803c &lt;data_handler_ptr&gt;:
    803c:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4

00008040 &lt;unused_handler_ptr&gt;:
    8040:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4

00008044 &lt;irq_handler_ptr&gt;:
    8044:	000082b8 			; &lt;UNDEFINED&gt; instruction: 0x000082b8

00008048 &lt;fiq_handler_ptr&gt;:
    8048:	000082b4 			; &lt;UNDEFINED&gt; instruction: 0x000082b4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The branching instructions load address of the interrupt function to “pc” register. However,
the address of the function is stored somewhere and compiler generates access to this storage
using relative offset to current “pc” register. This is the reason why we have to copy not
just the branching instructions, but also the storage area where addresses of interrupt
routines are stored:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    ;@ Copy interrupt vector to its place
    ldr r0,=_entry
    mov r1,#0x0000

    ;@  Here we copy the branching instructions
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}

    ;@  Here we copy the branching addresses
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_memory_allocation">Dynamic Memory Allocation</h3>
<div class="paragraph">
<p>Let&#8217;s try to compile simple application that uses dynamic memory allocation. The
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector">test_cpp_vector</a>
application contains the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MaxVecSize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MaxVecSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It may happen that linking operation will fail with multiple referenced symbols being undefined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>unwind-arm.c:(.text+0x224): undefined reference to `__exidx_end'
unwind-arm.c:(.text+0x228): undefined reference to `__exidx_start'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-abort.o): In function `abort':
abort.c:(.text.abort+0x10): undefined reference to `_exit'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-sbrkr.o): In function `_sbrk_r':
sbrkr.c:(.text._sbrk_r+0x18): undefined reference to `_sbrk'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-signalr.o): In function `_kill_r':
signalr.c:(.text._kill_r+0x1c): undefined reference to `_kill'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-signalr.o): In function `_getpid_r':
signalr.c:(.text._getpid_r+0x4): undefined reference to `_getpid'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-writer.o): In function `_write_r':
writer.c:(.text._write_r+0x20): undefined reference to `_write'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-closer.o): In function `_close_r':
closer.c:(.text._close_r+0x18): undefined reference to `_close'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-fstatr.o): In function `_fstat_r':
fstatr.c:(.text._fstat_r+0x1c): undefined reference to `_fstat'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-isattyr.o): In function `_isatty_r':
isattyr.c:(.text._isatty_r+0x18): undefined reference to `_isatty'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-lseekr.o): In function `_lseek_r':
lseekr.c:(.text._lseek_r+0x20): undefined reference to `_lseek'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-readr.o): In function `_read_r':
readr.c:(.text._read_r+0x20): undefined reference to `_read'
collect2: error: ld returned 1 exit status</code></pre>
</div>
</div>
<div class="paragraph">
<p>The symbols <code>__exidx_start</code> and <code>__exidx_end</code> are required to indicate start and end of
<code>.ARM.exidx</code> section. It is used for exception handling. They must be defined in the linker script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>.ARM.exidx :
{
    __exidx_start = .;
    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    __exidx_end = .;
} &gt;RAM</code></pre>
</div>
</div>
<div class="paragraph">
<p>The dynamic memory allocation will require implementation of <code>_sbrk</code> function which will be used
to allocate chunks of memory for the C/C&#43;&#43; heap management.</p>
</div>
<div class="paragraph">
<p>All other symbols will be required to properly support exceptions which are used
by C&#43;&#43; heap management system.
<a href="https://sourceware.org/newlib/libc.html#Syscalls">Here</a> is a good resource,
that lists all the system calls, the developer may need to implement, to get
the application compiled.</p>
</div>
<div class="paragraph">
<p>Now, after successful compilation, take a good look at the size of the images of two sample applications we compiled. The paths are <code>&lt;build_dir&gt;/src/test_cpp/test_cpp_simple/kernel.img</code> and <code>&lt;build_dir&gt;/src/test_cpp/test_cpp_vector/kernel.img</code>.</p>
</div>
<div class="paragraph">
<p><strong>Side note</strong>: The image can be generated out of elf binary using the following instruction:
    &gt; arm-none-eabi-objcopy &lt;elf_executable&gt; -O binary &lt;binary_image_path&gt;</p>
</div>
<div class="paragraph">
<p>You may notice that size of
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector">test_cpp_vector</a> image
is greater by approximately 100K than
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple">test_cpp_simple</a>.
It is due to C&#43;&#43; heap management and exceptions handling. Let&#8217;s try to see what happens to the size
of the application if "C&#43;&#43;" heap is replaced with “C” one without exceptions.
You will have to override all the global C&#43;&#43; operators responsible for memory allocation/deallocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include &lt;cstdlib&gt;
#include &lt;new&gt;
</span>
<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="err">}</span>

<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="err">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// Same as regular new</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Same as regular delete</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// Same as regular new</span>
<span class="err">}</span>

<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>  <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Same as regular delete</span>
<span class="err">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// Same as regular new</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>  <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Same as regular delete</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please compile the
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector">test_cpp_vector</a>
application again, create its image and take a look at its size. It will be much closer to the size
of the <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple">test_cpp_simple</a>
image. In fact, you may not even need majority of the system call functions you have implemented before.
Try to remove them one by one and see whether linker still reports “undefined reference” to these symbols.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: Usage of C&#43;&#43; heap brings a significant code size overhead.
It is a good practice to override implementation of <code>new</code> and <code>delete</code> operators
with usage of <code>malloc</code> and <code>free</code> when using C&#43;&#43; in bare metal development.
Note that in this case, if memory allocation fails
<a href="http://en.cppreference.com/w/cpp/types/nullptr_t">nullptr</a> will be returned
instead of throwing
<a href="http://en.cppreference.com/w/cpp/memory/new/bad_alloc">std::bad_alloc</a> exception,
so beware of third party C&#43;&#43; libraries that count on exception been thrown and
do not check the returned value form
<a href="http://en.cppreference.com/w/cpp/memory/new/operator_new">operator new</a>.</p>
</div>
<div class="sect3">
<h4 id="_excluding_usage_of_dynamic_memory">Excluding Usage of Dynamic Memory</h4>
<div class="paragraph">
<p>The dynamic memory allocation is a core part of conventional C&#43;&#43;. However, in
some bare-metal products the usage of dynamic memory may be problematic and/or
forbidden. The only way (I know of) to make to compilation fail, if dynamic
memory is used, is to exclude standard library altogether. With <code>gcc</code> compiler
it is achieved by using <code>-nostdlib</code> compilation option.</p>
</div>
<div class="paragraph">
<p>Excluding standard library from the compilation will remove the whole C&#43;&#43;
run-time environment, which includes dynamic memory (heap) management and
exception handling. The implication of using this compilation option will be
described later in <a href="#compiler_output-nostdlib">Removing Standard Library and C&#43;&#43; Runtime</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="compiler_output-exceptions">Exceptions</h3>
<div class="paragraph">
<p>Exception handling is also a core feature of the conventional C&#43;&#43;. However,
this feature is considered to be too dangerous, because of unpredictable code
execution time and too expensive (in terms of code size) for bare metal platforms.
The usage of single throw statement in the source code will result in more than
120KB of extra binary code in the final binary image. Just try it yourself with
your compiler and see the difference in size of the produced binary images.</p>
</div>
<div class="paragraph">
<p>It is possible to forbid usage of throw statements by providing certain options
to the compiler. For GNU compiler (<code>gcc</code>) please use <code>-fno-exceptions</code>
in conjunction with <code>-fno-unwind-tables</code> options. According to
<a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html">this page</a>
of <code>gcc</code> manual, all the throw statements are supposed to be replaced with call
to <code>abort()</code>. Unfortunately this information seems to be outdated. The behaviour
I see with my latest (at the moment of writing) <code>gcc</code> version 4.8 is a bit different.</p>
</div>
<div class="paragraph">
<p>When the compilation is performed with the options specified above and there is
a <code>throw</code> statement in the code (for example <code>throw std::runtime_error("Some error")</code>),
the compilation fails with error message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>main.cpp:34:42: error: exception handling disabled, use -fexceptions to enable
     throw std::runtime_error("Some error");</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, all the <code>throw</code> statements from standard library are compiled in and
cause the whole exception handling support code overhead to be included in the
final binary image, despite the compilation options forbidding the exceptions.
The test application
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_exceptions">test_cpp_exceptions</a>
has simple code that causes the exceptions to be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated code of the main function looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00015f60 &lt;main&gt;:
   15f60:	e92d4008 	push	{r3, lr}
   15f64:	e59f0000 	ldr	r0, [pc]	; 15f6c &lt;main+0xc&gt;
   15f68:	eb0000a8 	bl	16210 &lt;_ZSt20__throw_out_of_rangePKc&gt;
   15f6c:	00013868 	andeq	r3, r1, r8, ror #16</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also can see there are multiple exception related functions in the produced
listing, such as <code>__cxa_allocate_exception</code>, <code>__cxa_throw</code>, <code>_ZSt20__throw_out_of_rangePKc</code>,
<code>_ZSt21__throw_bad_exceptionv</code>, etc&#8230;&#8203; The size of the binary image will also
be huge (about 125KB) due to exceptions handling.</p>
</div>
<div class="paragraph">
<p>If you would like to use STL classes that may throw exceptions, such as
<code>std::string</code>, <code>std::vector</code>, but refuse to pay the expensive price of extra
code space for exceptions handling, you&#8217;ll have to do two things. First, make
sure that exception conditions never occur in your code run, i.e.
if <code>throw</code> statement is about to get executed, it means there is a bug in your
code. Second, override the definition of all the "__throw_*" functions the
compiler tries to use. In order to identify all these functions you&#8217;ll have to
temporarily disable usage of standard library by passing <code>-nostdlib</code> compilation
option to your <code>gcc</code> compiler. For the code example above the compilation
without standard library will fail with error message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>main.cpp.o: In function `main':
main.cpp:(.text.startup+0x8): undefined reference to `std::__throw_out_of_range(char const*)'
collect2: error: ld returned 1 exit status</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try to override <code>std::__throw_out_of_range(char const*)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>

<span class="kt">void</span> <span class="n">__throw_out_of_range</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This time the compilation will succeed. Let&#8217;s now compile the result code with
standard library included (without using <code>-nostdlib</code> option) and check the
binary image size. With my compiler the size is 1.3KB, which is much much better
than 120KB when exception handling is used.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION:</strong> Excluding exception handling support is a well known and
widely used practice in C&#43;&#43; bare metal development. Even when relevant
compilation options are used (<code>-fno-exceptions</code> and <code>-fno-unwind-tables</code> in GNU compiler),
there is still a need to override various <code>__throw_*</code> functions used by the
compiler and provided by the standard library.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rtti">RTTI</h3>
<div class="paragraph">
<p><strong>Run Time Type Information</strong> is also one of the core features of conventional C&#43;&#43;.
It allows retrieval of the object type information (using
<a href="http://en.cppreference.com/w/cpp/language/typeid">typeid</a> operator) as well as checking the
inheritance hierarchy (using
<a href="http://en.cppreference.com/w/cpp/language/dynamic_cast">dynamic_cast</a>) at run time.
The RTTI is available only when there is a polymorphic behaviour, i.e. the classes
have at least one virtual function.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try to analyse the generated code when RTTI is in use.
The <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_rtti">test_cpp_rtti</a>
application in <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project contains the
code listed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">SomeClass</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">someFunc</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in *.cpp file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SomeClass</span><span class="o">::</span><span class="n">someFunc</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SomeClass</span> <span class="n">someClass</span><span class="p">;</span>
<span class="n">someClass</span><span class="p">.</span><span class="n">someFunc</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s open the listing file and see what&#8217;s going on in there.
The address of <code>SomeClass::someFunc()</code> seems to be <code>0x8300</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008300 &lt;_ZN9SomeClass8someFuncEv&gt;:
    8300:	e12fff1e 	bx	lr</code></pre>
</div>
</div>
<div class="paragraph">
<p>The virtual table for <code>SomeClass</code> class must be somewhere in <code>.rodata</code> section and contain
address of <code>SomeClass::someFunc()</code>, i.e. it must have <code>0x8300</code> value inside:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Disassembly of section .rodata:

...
00009c10 &lt;_ZTV9SomeClass&gt;:
    9c10:	00000000 	andeq	r0, r0, r0
    9c14:	00009c04 	andeq	r9, r0, r4, lsl #24
    9c18:	00008300 	andeq	r8, r0, r0, lsl #6
    9c1c:	00000000 	andeq	r0, r0, r0</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is visible that compiler added some more entries to the virtual table in addition to the
single virtual function we implemented. The address <code>0x9c04</code> is also located in
<code>.rodata</code> section. It is some type related table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00009c04 &lt;_ZTI9SomeClass&gt;:
    9c04:	00009c28 	andeq	r9, r0, r8, lsr #24
    9c08:	00009bf8 	strdeq	r9, [r0], -r8
    9c0c:	00000000 	andeq	r0, r0, r0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>0x9c28</code> and <code>0x9bf8</code> are addresses in <code>.rodata*</code> section(s).
The <code>0x9bf8</code> address seems to contain some data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00009bf8 &lt;_ZTS9SomeClass&gt;:
    9bf8:	6d6f5339 	stclvs	3, cr5, [pc, #-228]!	; 9b1c &lt;strcmp+0x180&gt;
    9bfc:	616c4365 	cmnvs	ip, r5, ror #6
    9c00:	00007373 	andeq	r7, r0, r3, ror r3</code></pre>
</div>
</div>
<div class="paragraph">
<p>After a closer look we may decode this data to be <code>9SomeClass</code> ascii string.</p>
</div>
<div class="paragraph">
<p>Address <code>0x9c28</code> is in the middle of some type related information table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00009c20 &lt;_ZTVN10__cxxabiv117__class_type_infoE&gt;:
    9c20:	00000000 	andeq	r0, r0, r0
    9c24:	00009c50 	andeq	r9, r0, r0, asr ip
    9c28:	00009dc0 	andeq	r9, r0, r0, asr #27
    9c2c:	00009de4 	andeq	r9, r0, r4, ror #27
    9c30:	0000a114 	andeq	sl, r0, r4, lsl r1
    9c34:	0000a11c 	andeq	sl, r0, ip, lsl r1
    9c38:	00009e40 	andeq	r9, r0, r0, asr #28
    9c3c:	00009d48 	andeq	r9, r0, r8, asr #26
    9c40:	00009e10 	andeq	r9, r0, r0, lsl lr
    9c44:	00009e94 	muleq	r0, r4, lr
    9c48:	00009dac 	andeq	r9, r0, ip, lsr #27
    9c4c:	00000000 	andeq	r0, r0, r0</code></pre>
</div>
</div>
<div class="paragraph">
<p>How these tables are used by the compiler is of little interest to us. What is interesting
is a code size overhead. Lets check the size of the binary image. With my compiler it is
a bit more than 13KB.</p>
</div>
<div class="paragraph">
<p>For some bare metal platforms it may be undesirable or even impossible to have this amount
of extra binary code added to the binary image. The GNU compiler (<code>gcc</code>) provides an ability
to disable <strong>RTTI</strong> by using <code>-no-rtti</code> option. Let&#8217;s check the virtual table of <code>SomeClass</code>
class when this option is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Disassembly of section .rodata:

00008320 &lt;_ZTV9SomeClass&gt;:
	...
    8328:	00008300 	andeq	r8, r0, r0, lsl #6
    832c:	00000000 	andeq	r0, r0, r0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The virtual table looks much simpler now with single pointer to the <code>SomeClass::someFunc()</code>
virtual function. There is no extra code size overhead needed to maintain type information.
If the application above is compiled without exceptions (using <code>-fno-exceptions</code> and
<code>-fno-unwind-tables</code>) as well as without RTTI support (using <code>-no-rtti</code>) the binary
image size will be about 1.3KB which is much better.</p>
</div>
<div class="paragraph">
<p>However, if <code>-no-rtti</code> option is used, the compiler won&#8217;t allow usage of
<a href="http://en.cppreference.com/w/cpp/language/typeid">typeid</a> operator as well as
<a href="http://en.cppreference.com/w/cpp/language/dynamic_cast">dynamic_cast</a>.
In this case the developer needs to come up with other solutions to differentiate
between objects of different types (but having the same 'ancestor') at run time.
There are multiple idioms that can be used, such as using simple C-like approach
of <code>switch</code>-ing on some type enumerator member, or using polymorphic behaviour
of the objects to perform
<a href="http://en.wikipedia.org/wiki/Double_dispatch">double dispatch</a>.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: Disabling <strong>R</strong>un <strong>T</strong>ime <strong>T</strong>ype <strong>I</strong>nformation (RTTI)
in addition to eliminating exception handling is very common in bare metal
C&#43;&#43; development. It allows to save about 10KB of space overhead in final binary
image.</p>
</div>
</div>
<div class="sect2">
<h3 id="compiler_output-nostdlib">Removing Standard Library and C&#43;&#43; Runtime</h3>
<div class="paragraph">
<p>Due to platform RAM/ROM limitations it may be required to exclude not just support for
exceptions and RTTI (compiling with <code>-fno-exceptions</code> <code>-fno-unwind-tables</code> <code>-fno-rtti</code>),
but for dynamic memory allocation too. The latter includes passing <code>-nostdlib</code> option to the compiler.
In case when standard library is excluded, there is no startup code help
provided by the compiler, the developer will have to implement all the startup stages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>updating the interrupt vector table</p>
</li>
<li>
<p>setting up correct stack pointers for all the modes of execution</p>
</li>
<li>
<p>zeroing <code>.bss</code> section</p>
</li>
<li>
<p>calling initialisation functions for global objects</p>
</li>
<li>
<p>calling “main” function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s">Here</a> is an example of such startup code.</p>
</div>
<div class="paragraph">
<p>There also may be a need to provide an implementation of some functions or
definition of some global symbols. For example, if
<a href="http://en.cppreference.com/w/cpp/algorithm/copy">std::copy</a> algorithm is used
to copy multiple objects from place to place, the compiler might decide to use
<a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a> function provided by
the standard library, and as the result the build process will fail with
“undefined reference” error. The same way, usage of
<a href="http://en.cppreference.com/w/cpp/algorithm/fill">std::fill</a> algorithm may
require <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a> function.
Be ready to implement them when needed.</p>
</div>
<div class="paragraph">
<p>Another example is having call to
<a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind</a> function
with <a href="http://en.cppreference.com/w/cpp/utility/functional/placeholders">std::placeholders::_1</a>,
<a href="http://en.cppreference.com/w/cpp/utility/functional/placeholders">std::placeholders::_2</a>, etc.
There will be a need to define these placeholders as global symbols:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include &lt;functional&gt;
</span><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">placeholders</span>
<span class="p">{</span>

<span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">)</span> <span class="n">_1</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">)</span> <span class="n">_2</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_3</span><span class="p">)</span> <span class="n">_3</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_4</span><span class="p">)</span> <span class="n">_4</span><span class="p">;</span>

<span class="p">}</span>  <span class="c1">// namespace placeholders</span>
<span class="p">}</span>  <span class="c1">// namespace std</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if there is a need for the standard library in the product being developed,
it may be a good exercise as well as good debugging technique to temporarily
exclude it from the compilation. The compilation will probably fail in the
linking stage. The list of missing symbols and/or functions will provide a good
indication of what missing functionality is provided by the library. The
developer may notice that some components still require exceptions handling,
for example, resulting int the binary image being too big.</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_objects">Static Objects</h3>
<div class="paragraph">
<p>Let&#8217;s analyse the code that initialises static objects.
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_statics">test_cpp_statics</a>
is a simple application that has two static objects, one is in the global scope,
the other is in the function scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeObj</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="k">static</span> <span class="n">SomeObj</span><span class="o">&amp;</span> <span class="n">instanceGlobal</span><span class="p">();</span>
   <span class="k">static</span> <span class="n">SomeObj</span><span class="o">&amp;</span> <span class="n">instanceLocal</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="n">SomeObj</span><span class="p">(</span><span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m_v1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_v2</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">SomeObj</span> <span class="n">globalObj</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SomeObj</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">globalObj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="n">SomeObj</span><span class="o">&amp;</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">instanceGlobal</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">globalObj</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SomeObj</span><span class="o">&amp;</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">instanceLocal</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">SomeObj</span> <span class="n">localObj</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">localObj</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argc</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>

    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">glob</span> <span class="o">=</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">instanceGlobal</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">local</span> <span class="o">=</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">instanceLocal</span><span class="p">();</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">glob</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that compiler will try to inline the code above if implemented in the
same file. To properly analyse the code that initialises global variables,
you should put implementation of constructor and <code>instanceGlobal()</code>/<code>instanceLocal()</code>
functions into separate files. If <code>-nostdlib</code> option is passed to the compiler
to exclude linking with standard library, the compilation of the code above will
fail with following error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>main.cpp:(.text.startup+0x1c): undefined reference to `__cxa_guard_acquire'
main.cpp:(.text.startup+0x3c): undefined reference to `__cxa_guard_release'</code></pre>
</div>
</div>
<div class="paragraph">
<p>It means that compiler attempts to make static variables initialisation thread-safe.
The get it compiled you have to either implement the locking functionality yourself or
allow compiler to do it in an unsafe way by adding <code>-fno-threadsafe-statics</code> compilation option.
I think it is quite safe to use this option in the bare-metal development if you make sure the
statics are not accessed in the interrupt context or have been initialised at the beginning
of <code>main()</code> function before any interrupts are enabled. To grab a reference to such object
without any use is enough:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">local</span> <span class="o">=</span> <span class="n">SomeObj</span><span class="o">::</span><span class="n">instanceLocal</span><span class="p">();</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s analyse the initialisation of <code>globalObj</code>. The <code>.init.array</code> section contains
pointer to initialisation function <code>_GLOBAL__sub_I__ZN7SomeObj9globalObjE</code>.</p>
</div>
<div class="paragraph">
<p>Disassembly of section .init.array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008180 &lt;__init_array_start&gt;:
    8180:	00008154 	andeq	r8, r0, r4, asr r1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The initialisation function loads the address of the object and passes it to the constructor
of <code>SomeObj</code> together with the initialisation parameters (“1” and “2” integer values).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008154 &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE&gt;:
    8154:	e59f0008 	ldr	r0, [pc, #8]	; 8164 &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x10&gt;
    8158:	e3a01001 	mov	r1, #1
    815c:	e3a02002 	mov	r2, #2
    8160:	eaffffee 	b	8120 &lt;_ZN7SomeObjC1Eii&gt;
    8164:	00008168 	andeq	r8, r0, r8, ror #2

00008168 &lt;_ZN7SomeObj9globalObjE&gt;:
	...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above loads the address of the global object (<code>0x00008168</code>) into <strong>r0</strong>, and
initialisation parameters into <strong>r1</strong> and <strong>r2</strong>, then invokes the constructor of <code>SomeObj</code>.</p>
</div>
<div class="paragraph">
<p>Please remember to call all the initialisation functions from <code>.init.array</code> section in
your startup code before calling the <code>main()</code> function.</p>
</div>
<div class="paragraph">
<p>In the linker file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    .init.array :
    {
        __init_array_start = .;
        *(.init_array)
        *(.init_array.*)
        __init_array_end = .;
    } &gt; RAM</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the startup code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    ;@ Call constructors of all global objects
    ldr r0, =__init_array_start
    ldr r1, =__init_array_end

globals_init_loop:
    cmp     r0,r1
    it      lt
    ldrlt   r2, [r0], #4
    blxlt   r2
    blt     globals_init_loop

    ;@ Main function
    bl main
    b reset ;@ restart if main function returns</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if standard library is <strong>NOT</strong> excluded explicitly from the compilation,
the <code>__libc_init_array</code> provided by the standard library may be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    ;@ Call constructors of all global objects
    bl	__libc_init_array

    ;@ Main function
    bl main
    b reset ;@ restart if main function returns</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s also perform analysis of initialisation of <code>localObj</code> in <code>SomeObj::instanceLocal()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080e4 &lt;_ZN7SomeObj13instanceLocalEv&gt;:
    80e4:	e92d4010 	push	{r4, lr}
    80e8:	e59f4028 	ldr	r4, [pc, #40]	; 8118 &lt;_ZN7SomeObj13instanceLocalEv+0x34&gt;
    80ec:	e5943008 	ldr	r3, [r4, #8]
    80f0:	e3130001 	tst	r3, #1
    80f4:	1a000005 	bne	8110 &lt;_ZN7SomeObj13instanceLocalEv+0x2c&gt;
    80f8:	e284000c 	add	r0, r4, #12
    80fc:	e3a01003 	mov	r1, #3
    8100:	e3a02004 	mov	r2, #4
    8104:	eb000005 	bl	8120 &lt;_ZN7SomeObjC1Eii&gt;
    8108:	e3a03001 	mov	r3, #1
    810c:	e5843008 	str	r3, [r4, #8]
    8110:	e59f0004 	ldr	r0, [pc, #4]	; 811c &lt;_ZN7SomeObj13instanceLocalEv+0x38&gt;
    8114:	e8bd8010 	pop	{r4, pc}
    8118:	00008168 	andeq	r8, r0, r8, ror #2
    811c:	00008174 	andeq	r8, r0, r4, ror r1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above loads the address of the flag that indicates that the object was already
initialised into <strong>r4</strong>, then loads the value into <strong>r3</strong> and checks it using <code>tst</code> instruction.
If the flag indicates that the object wasn&#8217;t initialised, the constructor of the object is
called and the flag value is updated prior to returning address of the object.  Note that
<code>tst r3, #1</code> instruction performs binary <strong>AND</strong> between value <strong>r3</strong> and integer value <strong>#1</strong>,
then next <code>bne</code> instruction performs branch if result is not 0, i.e. the object was already initialised.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: Access to global objects are a bit cheaper than access to local static ones,
because access to the latter involves a check whether the object was already initialised.</p>
</div>
<div class="sect3">
<h4 id="_custom_destructors">Custom Destructors</h4>
<div class="paragraph">
<p>And what about destruction of static objects with non-trivial destructors? Let&#8217;s add a destructor to the above class and try to compile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeObj</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="o">~</span><span class="n">SomeObj</span><span class="p">();</span>
    <span class="err">…</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in *.cpp file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SomeObj</span><span class="o">::~</span><span class="n">SomeObj</span><span class="p">()</span> <span class="p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This time the compilation will fail with following errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>CMakeFiles/03_test_statics.dir/SomeObj.cpp.o: In function `SomeObj::instanceLocal()':
SomeObj.cpp:(.text+0x44): undefined reference to `__aeabi_atexit'
SomeObj.cpp:(.text+0x58): undefined reference to `__dso_handle'
CMakeFiles/03_test_statics.dir/SomeObj.cpp.o: In function `_GLOBAL__sub_I__ZN7SomeObj9globalObjE':
SomeObj.cpp:(.text.startup+0x28): undefined reference to `__aeabi_atexit'
SomeObj.cpp:(.text.startup+0x34): undefined reference to `__dso_handle'</code></pre>
</div>
</div>
<div class="paragraph">
<p>According to <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0041d/IHI0041D_cppabi.pdf">this</a>
document, the <code>__aeabi_atexit</code> function is used to register pointer to the
destructor function together with pointer to the relevant static object to be
destructed after <code>main</code> function returns. The reason for this behaviour is that
these objects must be destructed in the opposite order to which they were
constructed. The compiler cannot know the exact construction order for local
static objects. There may even be some static objects are not constructed at all.
The <code>__dso_handle</code> is a global pointer to the current address where the next
<strong>{destructor_ptr, object_ptr}</strong> pair will be stored.
The <code>main</code> function of most bare metal applications is not supposed to return
and global/static objects will not be destructed. In this case it will be enough
to implement the required function the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">__aeabi_atexit</span><span class="p">(</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">dso_handle</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">destructor</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dso_handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">__dso_handle</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if your <code>main</code> function returns and then the code jumps back to the
initialisation/reset routine, there is a need to properly perform destruction of
global/static objects. You&#8217;ll have to allocate enough space to store all the
necessary <strong>{destructor_ptr, object_ptr}</strong> pairs, then in <code>__aeabi_atexit</code>
function store the pair in the area pointed by <code>__dso_handle</code>, while incrementing
value of later. Note, that <code>dso_handle</code> parameter to the <code>__aeabi_atexit</code> function
is actually a pointer to the global <code>__dso_handle</code> value. Then, when the
<code>main</code> function returns, invoke the stored destructors in the opposite order
while passing addresses of the relevant objects as their first arguments.</p>
</div>
<div class="paragraph">
<p>To verify all the stated above let&#8217;s take a look again at the generated code of
initialisation function (after the destructor was added):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008170 &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE&gt;:
    8170:	e92d4010 	push	{r4, lr}
    8174:	e59f4020 	ldr	r4, [pc, #32]	; 819c &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x2c&gt;
    8178:	e3a01001 	mov	r1, #1
    817c:	e1a00004 	mov	r0, r4
    8180:	e3a02002 	mov	r2, #2
    8184:	ebffffeb 	bl	8138 &lt;_ZN7SomeObjC1Eii&gt;
    8188:	e1a00004 	mov	r0, r4
    818c:	e59f100c 	ldr	r1, [pc, #12]	; 81a0 &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x30&gt;
    8190:	e59f200c 	ldr	r2, [pc, #12]	; 81a4 &lt;_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x34&gt;
    8194:	e8bd4010 	pop	{r4, lr}
    8198:	eaffffe9 	b	8144 &lt;__aeabi_atexit&gt;
    819c:	000081a8 	andeq	r8, r0, r8, lsr #3
    81a0:	00008140 	andeq	r8, r0, r0, asr #2
    81a4:	000081bc 			; &lt;UNDEFINED&gt; instruction: 0x000081bc

00008140 &lt;_ZN7SomeObjD1Ev&gt;:
    8140:	e12fff1e 	bx	lr

000081bc &lt;__dso_handle&gt;:
    81bc:	00000000 	andeq	r0, r0, r0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Indeed, the call to the constructor immediately followed by the call to
<code>__aeabi_atexit</code> with address of the object in <strong>r0</strong> (first parameter),
address of the destructor in <strong>r1</strong> (second parameter) and address of
<code>__dso_handle</code> in <strong>r2</strong> (third parameter).</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: It is better to design the “main” function to contain infinite
loop and never return to save the implementation of destructing global/static
objects functionality.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_abstract_classes">Abstract Classes</h3>
<div class="paragraph">
<p>The next thing to test is having abstract classes with pure virtual functions
while excluding linkage to standard library (using <code>-nostdlib</code> compilation option).
Below is an excerpt from
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_abstract_class">test_cpp_abstract_class</a>
application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">AbstractBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractBase</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">nonOverridenFunc</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Derived</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">AbstractBase</span><span class="o">::~</span><span class="n">AbstractBase</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AbstractBase</span><span class="o">::</span><span class="n">nonOverridenFunc</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">Derived</span><span class="o">::~</span><span class="n">Derived</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Derived</span><span class="o">::</span><span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">c</span><span class="o">++</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in the “main” function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Derived</span> <span class="n">obj</span><span class="p">;</span>
<span class="n">AbstractBase</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
<span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The compilation will fail with following errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>CMakeFiles/04_test_abstract_class.dir/AbstractBase.cpp.o: In function `AbstractBase::~AbstractBase()':
AbstractBase.cpp:(.text+0x24): undefined reference to `operator delete(void*)'
CMakeFiles/04_test_abstract_class.dir/AbstractBase.cpp.o:(.rodata+0x10): undefined reference to `__cxa_pure_virtual'
CMakeFiles/04_test_abstract_class.dir/Derived.cpp.o: In function `Derived::~Derived()':
Derived.cpp:(.text+0x3c): undefined reference to `operator delete(void*)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>__cxa_pure_virtual</code> is a function, address of which compiler writes in the
virtual table when the function is pure virtual. It may be called due to some
unnatural pointer abuse or when trying to invoke pure virtual function in the
destructor of the abstract base class. The call to this function should never
happen in the normal application run. If it happens it means there is a bug.
It is quite safe to implement this function with infinite loop or some way to
report the error to the developer, by flashing leds for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">__cxa_pure_virtual</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The requirement for <code>operator delete(void*)</code> is quite strange though, there is no dynamic
memory allocation in the source code. It has to be investigated. Let&#8217;s stub the
function and check the output of the compiler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The virtual tables for the classes reside in <code>.rodata</code> section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Disassembly of section .rodata:

000081a0 &lt;_ZTV12AbstractBase&gt;:
	...
    81a8:	000080d8 	ldrdeq	r8, [r0], -r8	; &lt;UNPREDICTABLE&gt;
    81ac:	000080ec 	andeq	r8, r0, ip, ror #1
    81b0:	0000815c 	andeq	r8, r0, ip, asr r1
    81b4:	000080e8 	andeq	r8, r0, r8, ror #1

000081b8 &lt;_ZTV7Derived&gt;:
	...
    81c0:	00008110 	andeq	r8, r0, r0, lsl r1
    81c4:	00008130 	andeq	r8, r0, r0, lsr r1
    81c8:	0000810c 	andeq	r8, r0, ip, lsl #2
    81cc:	000080e8 	andeq	r8, r0, r8, ror #1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last entry for both classes has the address of <code>AbstractBase::nonOverridenFunc</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080e8 &lt;_ZN12AbstractBase16nonOverridenFuncEv&gt;:
    80e8:	e12fff1e 	bx	lr</code></pre>
</div>
</div>
<div class="paragraph">
<p>The third entry in the virtual table of <strong>Derived</strong> class has the address of
<code>Derived::func</code> function, while the third entry in the virtual table of
<strong>AbstractBase</strong> class has the address of <code>__cxa_pure_virtual</code>,
just like expected.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>0000810c &lt;_ZN7Derived4funcEv&gt;:
    810c:	e12fff1e 	bx	lr

0000815c &lt;__cxa_pure_virtual&gt;:
    815c:	eafffffe 	b	815c &lt;__cxa_pure_virtual&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first two entries in the virtual tables point to two different
implementations of the destructor. The first entry has the address of normal
destructor implementation, and the second one has an address of the second
destructor implementation, that invokes operator delete
(has <code>_ZdlPv</code> symbol) after the destruction of the object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080d8 &lt;_ZN12AbstractBaseD1Ev&gt;:
    80d8:	e59f3004 	ldr	r3, [pc, #4]	; 80e4 &lt;_ZN12AbstractBaseD1Ev+0xc&gt;
    80dc:	e5803000 	str	r3, [r0]
    80e0:	e12fff1e 	bx	lr
    80e4:	000081a8 	andeq	r8, r0, r8, lsr #3

000080ec &lt;_ZN12AbstractBaseD0Ev&gt;:
    80ec:	e59f3014 	ldr	r3, [pc, #20]	; 8108 &lt;_ZN12AbstractBaseD0Ev+0x1c&gt;
    80f0:	e92d4010 	push	{r4, lr}
    80f4:	e1a04000 	mov	r4, r0
    80f8:	e5803000 	str	r3, [r0]
    80fc:	eb000015 	bl	8158 &lt;_ZdlPv&gt;
    8100:	e1a00004 	mov	r0, r4
    8104:	e8bd8010 	pop	{r4, pc}
    8108:	000081a8 	andeq	r8, r0, r8, lsr #3

00008110 &lt;_ZN7DerivedD1Ev&gt;:
    8110:	e59f3014 	ldr	r3, [pc, #20]	; 812c &lt;_ZN7DerivedD1Ev+0x1c&gt;
    8114:	e92d4010 	push	{r4, lr}
    8118:	e1a04000 	mov	r4, r0
    811c:	e5803000 	str	r3, [r0]
    8120:	ebffffec 	bl	80d8 &lt;_ZN12AbstractBaseD1Ev&gt;
    8124:	e1a00004 	mov	r0, r4
    8128:	e8bd8010 	pop	{r4, pc}
    812c:	000081c0 	andeq	r8, r0, r0, asr #3

00008130 &lt;_ZN7DerivedD0Ev&gt;:
    8130:	e59f301c 	ldr	r3, [pc, #28]	; 8154 &lt;_ZN7DerivedD0Ev+0x24&gt;
    8134:	e92d4010 	push	{r4, lr}
    8138:	e1a04000 	mov	r4, r0
    813c:	e5803000 	str	r3, [r0]
    8140:	ebffffe4 	bl	80d8 &lt;_ZN12AbstractBaseD1Ev&gt;
    8144:	e1a00004 	mov	r0, r4
    8148:	eb000002 	bl	8158 &lt;_ZdlPv&gt;
    814c:	e1a00004 	mov	r0, r4
    8150:	e8bd8010 	pop	{r4, pc}
    8154:	000081c0 	andeq	r8, r0, r0, asr #3

00008158 &lt;_ZdlPv&gt;:
    8158:	e12fff1e 	bx	lr</code></pre>
</div>
</div>
<div class="paragraph">
<p>It seems that when there is a virtual destructor, the compiler will have to
support direct invocation of the destructor as well as usage of operator delete.
In case of the former the compiler will use the first entry in the virtual table
for the destructor invocation, and in case of the latter the compiler will use
the second entry. Let&#8217;s try to add the following lines to our <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">basePtr</span><span class="o">-&gt;~</span><span class="n">AbstractBase</span><span class="p">();</span>
<span class="k">delete</span> <span class="n">basePtr</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The compiler will add the following instructions to the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    8190:	e59d3004 	ldr	r3, [sp, #4]
    8194:	e1a00004 	mov	r0, r4
    8198:	e5933000 	ldr	r3, [r3]
    819c:	e12fff33 	blx	r3
    81a0:	e59d3004 	ldr	r3, [sp, #4]
    81a4:	e1a00004 	mov	r0, r4
    81a8:	e5933004 	ldr	r3, [r3, #4]
    81ac:	e12fff33 	blx	r3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The address of the virtual table is written into <strong>r3</strong>, then value of <strong>r3</strong>
is overwritten with address of the destructor function to call, and the call is
executed using <code>blx</code> instruction. The first invocation takes the address of
destructor function from the first entry of virtual table, while the second
invocation takes the address from second entry (offseted by <code>#4</code>).
This is just like expected.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: Having virtual destructor may require an implementation of
<code>operator delete(void*)</code> even if there is no dynamic memory allocation.</p>
</div>
</div>
<div class="sect2">
<h3 id="compiler_output-templates">Templates</h3>
<div class="paragraph">
<p>Templates are notorious for the code bloating they produce. Some organisations
explicitly forbid usage of templates in their internal C&#43;&#43; coding standards.
However, templates is a very powerful tool, it is very difficult (if not impossible)
to write generic source code, that can be reused in multiple independent
projects/platforms without using templates, and without incurring any
significant performance penalties. I think developers, who are afraid or not
allowed to use templates, will have to implement the same concepts/modules over
and over again with minor differences, which are project/platform specific.
To properly master the templates we have to see the Assembler code duplication,
that is generated by the compiler when templates are used. Let&#8217;s try to compile
a simple application
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_templates">test_cpp_templates</a>
 that uses templated function with different type of input parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">startValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argc</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">start2</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

    <span class="n">func</span><span class="p">(</span><span class="n">start1</span><span class="p">);</span>
    <span class="n">func</span><span class="p">(</span><span class="n">start2</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may notice that function <code>func</code> is called with two parameters, one of type
<code>int</code> the other of type <code>unsigned</code>. These types have both the same size and
should generate more or less identical code. Let&#8217;s take a look at the generated
code of <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008504 &lt;main&gt;:
    8504:	e92d4008 	push	{r3, lr}
    8508:	e3a00064 	mov	r0, #100	; 0x64
    850c:	ebfffefc 	bl	8104 &lt;_Z4funcIiEvT_&gt;
    8510:	e3a000c8 	mov	r0, #200	; 0xc8
    8514:	ebffff3a 	bl	8204 &lt;_Z4funcIjEvT_&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yes, indeed, there are two calls to two different functions. However, the assembler
code of these functions is almost identical. Let&#8217;s also try to reuse the same
function with the same types but from different source file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">other</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">start2</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>

    <span class="n">func</span><span class="p">(</span><span class="n">start1</span><span class="p">);</span>
    <span class="n">func</span><span class="p">(</span><span class="n">start2</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated code is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080d8 &lt;_Z5otherv&gt;:
    80d8:	e92d4008 	push	{r3, lr}
    80dc:	e3a00f4b 	mov	r0, #300	; 0x12c
    80e0:	eb000007 	bl	8104 &lt;_Z4funcIiEvT_&gt;
    80e4:	e3a00f7d 	mov	r0, #500	; 0x1f4
    80e8:	eb000045 	bl	8204 &lt;_Z4funcIjEvT_&gt;
    80ec:	e8bd8008 	pop	{r3, pc}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We see that the same functions at the same addresses are called, i. e. the linker does its
job of removing duplicates of the same functions from different object files.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s also try to wrap the same function with a class and add one more template argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TDummy</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">SomeTemplateClass</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">startValue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startValue</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startValue</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note the dummy template parameter <code>TDummy</code> that is not used. Now, we
add two more calls to the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">SomeTemplateClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
    <span class="n">SomeTemplateClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that the functionality of the calls is identical. The only difference is the dummy
template argument. Let&#8217;s take a look at the generated code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>00008504 &lt;main&gt;:
    ...
    8518:	e3a00f7d 	mov	r0, #500	; 0x1f4
    851c:	ebffff78 	bl	8304 &lt;_ZN17SomeTemplateClassIiLj5EE4funcEi&gt;
    8520:	e3a00f7d 	mov	r0, #500	; 0x1f4
    8524:	ebffffb6 	bl	8404 &lt;_ZN17SomeTemplateClassIiLj10EE4funcEi&gt;
    8528:	eafffffe 	b	8528 &lt;main+0x24&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The compiler generated calls to two different functions, binary code of which is identical.</p>
</div>
<div class="paragraph">
<p><strong>CONCLUSION</strong>: The templates indeed require extra care and consideration. It is also important
not to overthink things. The well known notion of “Do not do premature optimisations. It is
much easier to make correct code faster, than fast code correct.” is also applicable
to code size. Do not try to optimise your template code before the need arises.
Make it work and work correctly first.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tag_dispatching">Tag Dispatching</h3>
<div class="paragraph">
<p>The <a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">tag dispatching</a>
is a widely used idiom in C&#43;&#43; development. It used extensively in the following chapters
of this book.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try to compile
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_tag_dispatch">test_cpp_tag_dispatch</a>
application in
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project and take a look at the code
generated by the compiler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">Tag1</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="n">Tag2</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">Dispatcher</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTag</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">funcInternal</span><span class="p">(</span><span class="n">TTag</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">funcInternal</span><span class="p">(</span><span class="n">Tag1</span> <span class="n">tag</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">funcInternal</span><span class="p">(</span><span class="n">Tag2</span> <span class="n">tag</span><span class="p">);</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Dispatcher</span><span class="o">::</span><span class="n">func</span><span class="o">&lt;</span><span class="n">Tag1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Dispatcher</span><span class="o">::</span><span class="n">func</span><span class="o">&lt;</span><span class="n">Tag2</span><span class="o">&gt;</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code generated by the compiler looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080fc &lt;main&gt;:
    80fc:	e92d4008 	push	{r3, lr}
    8100:	e3a00000 	mov	r0, #0
    8104:	ebfffff3 	bl	80d8 &lt;_ZN10Dispatcher12funcInternalE4Tag1&gt;
    8108:	e3a00000 	mov	r0, #0
    810c:	ebfffff2 	bl	80dc &lt;_ZN10Dispatcher12funcInternalE4Tag2&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the <code>Tag1</code> and <code>Tag2</code> are empty classes, the compiler still uses
integer value <code>0</code> as a first parameter to the function.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try to optimise this redundant <code>mov r0, #0</code> instruction away by making
it visible to the compiler that the tag parameter is not used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Dispatcher</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTag</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">otherFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">otherFuncInternal</span><span class="p">(</span><span class="n">TTag</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">otherFuncInternal</span><span class="p">(</span><span class="n">Tag1</span> <span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
        <span class="n">otherFuncTag1</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">otherFuncInternal</span><span class="p">(</span><span class="n">Tag2</span> <span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
        <span class="n">otherFuncTag2</span><span class="p">();</span>
    <span class="p">}</span>


    <span class="k">static</span> <span class="kt">void</span> <span class="n">otherFuncTag1</span><span class="p">();</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">otherFuncTag2</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Somewhere in the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Dispatcher</span><span class="o">::</span><span class="n">otherFunc</span><span class="o">&lt;</span><span class="n">Tag1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Dispatcher</span><span class="o">::</span><span class="n">otherFunc</span><span class="o">&lt;</span><span class="n">Tag2</span><span class="o">&gt;</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code generated by the compiler looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>000080fc &lt;main&gt;:
    ...
    8110:	ebfffff2 	bl	80e0 &lt;_ZN10Dispatcher13otherFuncTag1Ev&gt;
    8114:	ebfffff2 	bl	80e4 &lt;_ZN10Dispatcher13otherFuncTag2Ev&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the compiler optimises away the tag parameter.</p>
</div>
<div class="paragraph">
<p>Based on the above we may make a <strong>CONCLUSION</strong>: When
the <a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">tag dispatching</a>
idiom is used, the function that receives a dummy (tag) parameter should be a simple inline wrapper
around other function that implements the required functionality. In this case the compiler will
optimise away the creation of tag object and will call the wrapped function directly.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic_needs-basic_needs">Basic Needs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Prior to describing various embedded (bare metal) development concepts I&#8217;d like to cover
several basic needs that, I think, most developers will have to use in their products.</p>
</div>
<div class="sect2">
<h3 id="_assertion">Assertion</h3>
<div class="paragraph">
<p>One of the basic needs during the development is having an ability to test various assumptions
and invariants in runtime when compiling the application in DEBUG mode and remove the checks
when compiling the application in RELEASE mode. The standard C&#43;&#43; reuses <code>assert()</code> macro from
standard C library.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include &lt;cassert&gt;
</span><span class="err">…</span>
<span class="n">assert</span><span class="p">(</span><span class="n">some_condition</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>assert()</code> macro evaluates to nothing in case <code>NDEBUG</code> symbol is defined, otherwise it
evaluates the condition. If the condition doesn&#8217;t return <code>true</code>, it calls the
<code>__assert_fail</code> function, provided by standard library, which in turn calls <code>printf</code>
to print error message to standard output followed by the call to <code>abort</code> function,
which is supposed to terminate an application.</p>
</div>
<div class="paragraph">
<p>Both <code>printf</code> and <code>abort</code> functions are provided by standard library. However, <code>printf</code>
will require the implementation of <code>_write</code> function to print characters to the debug
output terminal, and <code>abort</code> will require implementation of <code>_exit</code> function to
terminate the application.</p>
</div>
<div class="paragraph">
<p>If standard library is excluded from the compilation (using <code>-nostdlib</code> compilation option),
the compilation will fail with <code>undefined reference to __assert_func</code> error message.
The developer will have to implement this function with correct signature. To retrieve
the correct signature you will have to open <code>assert.h</code> standard header provided by your
compiler. It will be something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">__assert_fail</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">)</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__noreturn__</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The attribute specifies that this function doesn&#8217;t return, so the compiler will generate a
call to it without setting any address to return to.</p>
</div>
<div class="paragraph">
<p>The conclusion from all the stated above is that using standard <code>assert()</code> macro is possible,
but somewhat inflexible. It is possible to access only global variables from the functions
described above, i.e. if there is a need to flash a led to indicate assertion failure, then its
control must be accessible through global variables, which is a bit ugly. Another disadvantage
of this approach is that there are no convenient means to change the behaviour of the assert
failure functionality and after a while restore the original behaviour. Such behaviour may be
helpful to better identify the location of the assert that has failed. For example, override
the default assert failure behaviour with activating a specific led at the entrance of some
function, and restore the original assertion failure behaviour when function returns.</p>
</div>
<div class="paragraph">
<p>Below is a short description of a better way to handle assert checks and failures. The code is in
<a href="https://github.com/arobenko/embxx">embxx</a> library and can be reviewed
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/Assert.h">here</a>.</p>
</div>
<div class="paragraph">
<p>To resolve the problems described above and to handle the assertions C&#43;&#43; way we will have to create
generic assertion failure handling abstract class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Assert</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fail</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">expr</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">function</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When implementing custom project specific assertion failure behaviour inherit from the class above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include "embxx/util/Assert.h"
</span>
<span class="k">typedef</span> <span class="p">...</span> <span class="n">Led</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">LedOnAssert</span> <span class="o">:</span> <span class="k">public</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">Assert</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="n">LedOnAssert</span><span class="p">(</span><span class="n">Led</span><span class="o">&amp;</span> <span class="n">led</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">led_</span><span class="p">(</span><span class="n">led</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fail</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">expr</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">function</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">led_</span><span class="p">.</span><span class="n">on</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{;}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Led</span><span class="o">&amp;</span> <span class="n">led_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To manage an object of the class above, we will have to create a singleton class with static
instance. It will store a pointer to the currently registered assertion failure behaviour:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">AssertManager</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="k">static</span> <span class="n">AssertManager</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">AssertManager</span> <span class="n">mgr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">mgr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Assert</span><span class="o">*</span> <span class="n">reset</span><span class="p">(</span><span class="n">Assert</span><span class="o">*</span> <span class="n">newAssert</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prevAssert</span> <span class="o">=</span> <span class="n">assert_</span><span class="p">;</span>
        <span class="n">assert_</span> <span class="o">=</span> <span class="n">newAssert</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">prevAssert</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Assert</span><span class="o">*</span> <span class="n">getAssert</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">assert_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">hasAssertRegistered</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">assert_</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">infiniteLoop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{};</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">AssertManager</span><span class="p">()</span> <span class="o">:</span> <span class="n">assert_</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">Assert</span><span class="o">*</span> <span class="n">assert_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>reset</code> member function registers new object that manages assertion failure behaviour and
returns previous one, which can be used later to restore original behaviour.</p>
</div>
<div class="paragraph">
<p>We will require a new macro to check assertion condition and invoke registered failing behaviour:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#ifndef NDEBUG
</span>
<span class="cp">#define GASSERT(expr) \
    ((expr)                               \
      ? static_cast&lt;void&gt;(0)                     \
      : (embxx::util::AssertManager::instance().hasAssertRegistered() \
            ? embxx::util::AssertManager::instance().getAssert()-&gt;fail( \
                #expr, __FILE__, __LINE__, GASSERT_FUNCTION_STR) \
            : embxx::util::AssertManager::instance().infiniteLoop()))
</span>
<span class="cp">#else // #ifndef NDEBUG
</span>
<span class="cp">#define GASSERT(expr) static_cast&lt;void&gt;(0)
</span>
<span class="cp">#endif // #ifndef NDEBUG</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then in case of condition check failure, the <code>GASSERT()</code> macro checks whether any custom assertion
failure functionality registered and invokes its virtual <code>fail</code> function. If not, then infinite
loop is executed.</p>
</div>
<div class="paragraph">
<p>To complete the whole picture we have to provide a convenient way to register new assertion
failure behaviours:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">TAssert</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EnableAssert</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Assert</span><span class="p">,</span> <span class="n">TAssert</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
        <span class="s">"TAssert class must be derived class of Assert"</span><span class="p">);</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">TAssert</span> <span class="n">AssertType</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span>
    <span class="n">EnableAssert</span><span class="p">(</span><span class="n">Params</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">assert_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Params</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...),</span>
          <span class="n">prevAssert_</span><span class="p">(</span><span class="n">AssertManager</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assert_</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">EnableAssert</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">AssertManager</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">reset</span><span class="p">(</span><span class="n">prevAssert_</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">AssertType</span> <span class="n">assert_</span><span class="p">;</span>
    <span class="n">Assert</span><span class="o">*</span> <span class="n">prevAssert_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From now on, all we have do is to instantiate object of <code>EnableAssert</code> with the behaviour that
we want. Note that constructor of <code>EnableAssert</code> class can receive any number of parameters and
forwards them to the constructor of the internal <code>assert_</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Led</span> <span class="n">led</span><span class="p">;</span>
    <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">EnableAssert</span><span class="o">&lt;</span><span class="n">LedOnAssert</span><span class="o">&gt;</span> <span class="n">assertion</span><span class="p">(</span><span class="n">led</span><span class="p">);</span>

    <span class="p">...</span> <span class="c1">// Rest of the code</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If there is a need to temporarily override the previous assertion failure behaviour, just create
another <code>EnableAssert</code> object. Once the latter is out of scope (the object is destructed), previous
behaviour will be restored.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Led</span> <span class="n">led</span><span class="p">;</span>
    <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">EnableAssert</span><span class="o">&lt;</span><span class="n">LedOnAssert</span><span class="o">&gt;</span> <span class="n">assertion</span><span class="p">(</span><span class="n">led</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="p">{</span>
        <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">EnableAssert</span><span class="o">&lt;</span><span class="n">OtherAssert</span><span class="o">&gt;</span> <span class="n">otherAssertion</span><span class="p">(...</span><span class="cm">/* some params */</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>  <span class="c1">// restore previous registered behaviour – LedOnAssert.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>SUMMARY</strong>: The approach described above provides a flexible and convenient way to control how the
failures of various debug mode checks are reported to the developer. All the modules in
<a href="https://github.com/arobenko/embxx">embxx</a> library use the <code>GASSERT()</code> macro to verify their pre- and
post-conditions as well as internal assumptions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_callback">Callback</h3>
<div class="paragraph">
<p>As has been mentioned in the <a href="#overview-benefits">Benefits of C&#43;&#43;</a> chapter, the main reason for choosing
C&#43;&#43; over C is code reuse. When having some generic piece of code that tries to
use platform specific code and needs to receive some kind of notifications from the latter,
the need for some generic callback facility arises. C&#43;&#43; provides
<a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> class for this purpose,
it is possible to provide any callable object, such as
<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda function</a> or
<a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind</a> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">LowLevelPeripheral</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setEventCallback</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">eventCallback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">eventHandler</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventCallback_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">eventCallback_</span><span class="p">();</span> <span class="c1">// invoke registered callback object</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="n">eventCallback_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SomeGenericControl</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SomeGenericControl</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">periph_</span><span class="p">.</span><span class="n">setEventCallback</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SomeGenericControl</span><span class="o">::</span><span class="n">eventCallbackHandler</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">eventCallbackHandler</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="err">…</span> <span class="c1">// Handle the reported event.</span>
    <span class="p">}</span>

<span class="nl">private:</span>
     <span class="n">LowLevelPeripheral</span> <span class="n">periph_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two problems with using <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>.
It uses dynamic memory allocation and throws exception in case the function is invoked without
assigning callable object to it first. As a result
<a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> may be not suitable for use in
most of the bare metal projects. We will have to implement something similar, but without dynamic memory
allocations and without exceptions. Below is some short explanation of how to implement such a function
class. The implementation of the <code>StaticFunction</code> class is part of
<a href="https://github.com/arobenko/embxx">embxx</a> library and its full code listing can be viewed
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h">here</a>.</p>
</div>
<div class="paragraph">
<p>The restriction of inability to use dynamic memory allocation requires to use additional
parameter of storage size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TSignature</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticFunction</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It seems that in most cases the callback object will contain pointer to member function, pointer to
handling object and some additional single parameter. This is the reason for specifying the default
storage space as equal to the size of 3 pointers. The “signature” template parameter is exactly the
same as with <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> plus an
optional storage area size template parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">MyCallback</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MyOtherCallback</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To properly implement <code>operator()</code>, there is a need to split the signature into the return type and
rest of parameters. To achieve this the following template specialisation trick is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TRet</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticFunction</span><span class="o">&lt;</span><span class="n">TRet</span> <span class="p">(</span><span class="n">TArgs</span><span class="p">...),</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="n">TRet</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TArgs</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="p">{...}</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="err">…</span> <span class="n">StorageType</span><span class="p">;</span> <span class="c1">// Type of the storage area,</span>
                           <span class="c1">// will be explained later.</span>
    <span class="n">StorageType</span> <span class="n">handler_</span><span class="p">;</span> <span class="c1">// Storage area where the callback object</span>
                          <span class="c1">// is stored</span>
    <span class="kt">bool</span> <span class="n">valid_</span><span class="p">;</span> <span class="c1">// flag indicating whether storage are contains</span>
                 <span class="c1">// valid callback, initialised to false in</span>
                 <span class="c1">// default constructor</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>StaticFunction</code> object needs an ability to store any type of callable object as its internal
data member and then invoke it in its <code>operator()</code> member function. To support this functionality we
will require additional helper classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">StaticFunction</span><span class="o">&lt;</span><span class="n">TRet</span> <span class="p">(</span><span class="n">TArgs</span><span class="p">...),</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">private:</span>

    <span class="k">class</span> <span class="nc">Invoker</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Invoker</span><span class="p">()</span> <span class="p">{}</span>

        <span class="c1">// virtual invocation function</span>
        <span class="k">virtual</span> <span class="n">TRet</span> <span class="n">exec</span><span class="p">(</span><span class="n">TArgs</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>


    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBound</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">InvokerBound</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Invoker</span>
    <span class="p">{</span>
    <span class="nl">public:</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
        <span class="n">InvokerBound</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">InvokerBound</span><span class="p">()</span> <span class="p">{}</span>

        <span class="k">virtual</span> <span class="n">TRet</span> <span class="n">exec</span><span class="p">(</span><span class="n">TArgs</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">func_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="p">}</span>

    <span class="nl">private:</span>
        <span class="n">TBound</span> <span class="n">func_</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The callable object that will be stored in <code>handler_</code> data area and it will be of type
<code>InvokerBound&lt;&#8230;&#8203;&gt;</code> while invoked through interface of its base class <code>Invoker</code>.</p>
</div>
<div class="paragraph">
<p>There is a need to properly define <code>StorageType</code> for the <code>handler_</code> data member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">StorageAreaSize</span> <span class="o">=</span> <span class="n">TSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Invoker</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">typename</span>
    <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
        <span class="n">StorageAreaSize</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">Invoker</span><span class="o">&gt;::</span><span class="n">value</span>
   <span class="o">&gt;::</span><span class="n">type</span> <span class="n">StorageType</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>StorageType</code> is an uninitialised storage with alignment required to be able to store
object of type <code>Invoker</code>. The <code>InvokerBound&lt;&#8230;&#8203;&gt;</code> class will have the same alignment requirements
as its base class <code>Invoker</code>, so it is safe to store any object of type <code>InvokerBound&lt;&#8230;&#8203;&gt;</code> in the
same area, as long as its size doesn&#8217;t exceed the size of the <code>StorageType</code>.</p>
</div>
<div class="paragraph">
<p>Also note that the actual size of the storage area is the requested <code>TSize</code> plus the area required
to store the object of <code>Invoker</code> class. The size of <code>InvokerBound&lt;&#8230;&#8203;&gt;</code> object is size of its private
member plus the size of its base class <code>Invoker</code>, which will contain a single (hidden) pointer to
its virtual table.</p>
</div>
<div class="paragraph">
<p>Any callable object may be assigned to <code>StaticFunction</code> using either constructor or assignment
operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TRet</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticFunction</span><span class="o">&lt;</span><span class="n">TRet</span> <span class="p">(</span><span class="n">TArgs</span><span class="p">...),</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="n">StaticFunction</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">valid_</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assignHandler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">StaticFunction</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">destroyHandler</span><span class="p">();</span>
        <span class="n">assignHandler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
        <span class="n">valid_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">assignHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">DecayedFuncType</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">InvokerBound</span><span class="o">&lt;</span><span class="n">DecayedFuncType</span><span class="o">&gt;</span> <span class="n">InvokerBoundType</span><span class="p">;</span>

        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InvokerBoundType</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">StorageAreaSize</span><span class="p">,</span>
            <span class="s">"Increase the TSize template argument of the StaticFucntion"</span><span class="p">);</span>

        <span class="k">static_assert</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">Invoker</span><span class="p">)</span> <span class="o">==</span> <span class="k">alignof</span><span class="p">(</span><span class="n">InvokerBoundType</span><span class="p">),</span>
            <span class="s">"Alignment requirement for Invoker object must be the same "</span>
            <span class="s">"as alignment requirement for InvokerBoundType type object"</span><span class="p">);</span>

        <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">handler_</span><span class="p">)</span> <span class="n">InvokerBoundType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">destroyHandler</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">valid_</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Invoker</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler_</span><span class="p">);</span>
            <span class="n">invoker</span><span class="o">-&gt;~</span><span class="n">Invoker</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please pay attention that assignment operator has to call the destructor of previous function, that
was assigned to it, before storing a new callable object in its place.</p>
</div>
<div class="paragraph">
<p>Also note that there are compile time checks using
<a href="http://en.cppreference.com/w/cpp/language/static_assert">static_assert</a> that the size of the object to
store in the storage area doesn&#8217;t exceed the allocated size as well as alignment requirements still hold.</p>
</div>
<div class="paragraph">
<p>The invocation of the function will be implemented like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TRet</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticFunction</span><span class="o">&lt;</span><span class="n">TRet</span> <span class="p">(</span><span class="n">TArgs</span><span class="p">...),</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="n">TRet</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TArgs</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="n">valid_</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Invoker</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler_</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">invoker</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there are no exceptions in use and then the “must have” pre-condition for function invocation is
that a valid callable object has been assigned to it. That is the reason for assertion check in the body
of the function.</p>
</div>
<div class="paragraph">
<p>To complete the implementation of <code>StaticFunction</code> class the following logic must also be implemented:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check whether the <code>StaticFunction</code> object is valid, i.e has any callable object assigned to it.</p>
</li>
<li>
<p>Default construction - the function is invalid and cannot be invoked.</p>
</li>
<li>
<p>Copy/move construction + copy/move assignment functionality.</p>
</li>
<li>
<p>Clearing the function (invalidating).</p>
</li>
<li>
<p>Supporting both const and non-const <code>operator()</code> in the assigned callable object. It requires both const and non-const <code>operator()</code> implementation of <code>StaticFunction</code> as well as its internal <code>Invoker</code> and <code>InvokerBound&lt;&#8230;&#8203;&gt;</code> classes.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All this I leave as an exercise to to the reader. To see the complete implementation of the functionality
described above open <a href="https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h">this</a> link.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data_serialisation">Data Serialisation</h3>
<div class="paragraph">
<p>Another essential need in embedded development is an ability to serialise data. Most embedded
products read data from some kind of sensors and/or communicate with the control centre via
some wired or wireless serial interface.</p>
</div>
<div class="paragraph">
<p>Before data is sent via a communication link, it must be serialised into a buffer, and when
received, deserialised from bytes also in a different buffer on the other end. The data may be
serialised using big or little endian, based on the communication protocol used. The
<a href="https://github.com/arobenko/embxx">embxx</a> library provides a generic code with an ability to
read and write integral values from/to any buffer.
<a href="https://github.com/arobenko/embxx/blob/master/embxx/io/access.h">Here</a> is the source code for the
functions described below.</p>
</div>
<div class="paragraph">
<p>The functions below (defined in namespace <code>embxx::io</code>) support read and write of an integral
value using any type of iterator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeBig</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readBig</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeLittle</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readLittle</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions receive reference to iterator of a buffer/container. When bytes are read/written
from/to the buffer, the iterator is incremented. The iterator can be of any type as long as it
supports dereferencing (<code>operator*()</code>), pre-increment (<code>operator++</code>) and assignment to dereferenced
object. For example, serialising several values of various lengths into the array using big endian:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">value1</span> <span class="o">=</span> <span class="mh">0x0102</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">value2</span> <span class="o">=</span> <span class="mh">0x03040506</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">value3</span> <span class="o">=</span> <span class="mh">0x0708090a0b0c0d0e</span><span class="p">;</span>

<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value3</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of the buffer will be:
<code>{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c 0x0d, 0x0e, …}</code></p>
</div>
<div class="paragraph">
<p>Similar code of reading values from the buffer would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="k">auto</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">value2</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">value3</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example is serialising data into a container that has <code>push_back()</code> member functions,
such as <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a> or circular buffer.
The data will be added at the end of the existing one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="c1">// Will call push_back</span>
                                     <span class="c1">// on assignment</span>
<span class="err">…</span>
<span class="c1">// The writes below will use push_back for every byte.</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="p">(</span><span class="n">value3</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on a communication protocol there may be a need to serialise only part of the value.
For example some field of communication protocol is defined having only 3 bytes. In this case
the value will probably be stored in a variable of <code>std::uint32_t</code> type. There is similar set of
functions, but with additional template parameter that specifies how many bytes to read/write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeBig</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readBig</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeLittle</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readLittle</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So to read/write 3 bytes will look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeBig</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes the endianness of data serialisation may depend on some traits class parameters. In
order to be able to choose “Little” or “Big” variant functions at compile time instead of runtime the
tag parameter dispatch idiom must be used.</p>
</div>
<div class="paragraph">
<p>There are similar read/write functions, but instead of being differentiated by name they have additional
tag parameter to specify the endianness of serialisation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">/// Same as writeBig&lt;T, TIter&gt;(value, iter);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeData</span><span class="p">(</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">,</span>
    <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Big</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as writeBig&lt;TSize, T, TIter&gt;(value, iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeData</span><span class="p">(</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">,</span>
    <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Big</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as writeLittle&lt;T, TIter&gt;(value, iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeData</span><span class="p">(</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">,</span>
    <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Little</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as writeLittle&lt;TSize, T, TIter&gt;(value, iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">writeData</span><span class="p">(</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">,</span>
    <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Little</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as readBig&lt;T, TIter&gt;(iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Big</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as readBig&lt;TSize, T, TIter&gt;(iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Big</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as readLittle&lt;T, TIter&gt;(iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Little</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span>

<span class="c1">/// Same as readLittle&lt;TSize, T, TIter&gt;(iter)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="nf">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Little</span><span class="o">&amp;</span> <span class="n">endian</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>traits::endian::Big</code> and <code>traits::endian::Little</code> are defined as empty tag classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">traits</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">endian</span>
<span class="p">{</span>

<span class="k">struct</span> <span class="n">Big</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">Little</span> <span class="p">{};</span>

<span class="p">}</span>  <span class="c1">// namespace endian</span>

<span class="p">}</span>  <span class="c1">// namespace traits</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTraits</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SomeClass</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TTraits</span><span class="o">::</span><span class="n">Endianness</span> <span class="n">Endianness</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">serialise</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">writeData</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">Endianness</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">data_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So the code above is not aware what endianness is used to serialise the data. It is provided as
internal type of <code>Traits</code> class named <code>Endianness</code>. The compiler will generate the call to
appropriate <code>writeData()</code> function, which in turn forward it to <code>writeBig()</code> or <code>writeLittle()</code>.</p>
</div>
<div class="paragraph">
<p>To serialise data using big endian the traits should be defined as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">MyTraits</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">traits</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">Big</span> <span class="n">Endianness</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SomeClass</span><span class="o">&lt;</span><span class="n">MyTraits</span><span class="o">&gt;</span> <span class="n">someClassObj</span><span class="p">;</span>
<span class="err">…</span>
<span class="n">someClassObj</span><span class="p">.</span><span class="n">serialise</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span> <span class="c1">// Will serialise using big endian</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface described above is very easy and convenient to use and quite easy to implement using
straightforward approach. However, any variation of template parameters create an instantiation of
new binary code which may create significant code bloat if not used carefully. Consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read/write of signed vs unsigned integer values. The serialisation/deserialisation code is identical
for both cases, but won&#8217;t be considered as such when instantiating the functions. To optimise this case,
there is a need to implement read/write operations only for unsigned value, while the “signed” functions
become wrappers around the former. Don&#8217;t forget a sign extension operation when retrieving partial signed value.</p>
</li>
<li>
<p>The read/write operations are more or less the same for any length of the values, i.e of any types:
<code>(unsigned) char</code>, <code>(unsigned) short</code>, <code>(unsigned) int</code>, etc&#8230;&#8203; To optimise this case, there is a need
for internal function that receives length of serialised value as a run time parameter, while the functions
described above are mere wrappers around it.</p>
</li>
<li>
<p>Usage of the iterators also require caution. For example reading values may be performed using regular
<code>iterator</code> as well as <code>const_iterator</code>, i.e. iterator pointing to const values. These are two different
iterator types that will duplicate the “read” functionality if both of them are used:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="err">…</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">iter1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">iter2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// Instantiation 1</span>
<span class="k">auto</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span>

<span class="c1">// Instantiation 2</span>
<span class="k">auto</span> <span class="n">value2</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">readBig</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to optimise the case above for random access iterator by using temporary pointers to unsigned
characters to read the required value. After retrieval is complete, just increment the value of the passed
iterator with number of characters read.</p>
</div>
<div class="paragraph">
<p>All the consideration points stated above require quite complex implementation of the serialisation/deserialisation
functionality with multiple levels of abstraction which is beyond the scope of this book. It would be a
nice exercise to try and implement it yourself. Another option is to use the code as is from
<a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect2">
<h3 id="basic_needs-queue">Static (Fixed Size) Queue</h3>
<div class="paragraph">
<p>There is almost always a need to have some kind of a queuing functionality. A circular buffer is
a good compromise between speed of execution and memory consumption (vs
<a href="http://en.cppreference.com/w/cpp/container/deque">std::deque</a> for example). If your product allows
usage of dynamic memory allocation and/or exceptions than
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/circular_buffer.html">boost::circular_buffer</a> can be a
good choice. However, if using dynamic memory allocation is not an option, then there is no other
choice but to implement a circular buffer with maximum length known at compile time over C array
or <a href="http://en.cppreference.com/w/cpp/container/array">std::array</a>.
<a href="https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h">Here</a> is the implementation
of <code>StaticQueue</code> functionality from <a href="https://github.com/arobenko/embxx">embxx</a> library. I won&#8217;t go into
too much details or explain every line of code. Instead I will emphasise several important points
that must be taken into consideration.</p>
</div>
<div class="sect3">
<h4 id="_invalid_operations">Invalid operations</h4>
<div class="paragraph">
<p>There can always be an attempt to perform an invalid operation, such as access an element outside the
queue boundaries, or inserting new element when the queue is full, or popping an element when queue is
empty, etc&#8230;&#8203; The conventional way in C&#43;&#43; to handle these cases is to throw an exception.
However, in embedded and especially in bare metal programming it&#8217;s not an option. The right way to
handle these errors would be asserting on pre-conditions. The <code>StaticQueue</code> implementation in
<a href="https://github.com/arobenko/embxx">embxx</a> library uses <code>GASSERT()</code> macro described earlier.
The checks will be compiled only in non-Release mode (<code>NDEBUG</code> not defined) and in case of the
failure it will invoke the project specific code the developer has written to report assertion failure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">popFront</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constructiondestruction_of_the_elements">Construction/Destruction of the elements</h4>
<div class="paragraph">
<p>When the queue is created it doesn&#8217;t contain any elements. However, it must contain uninitialised space
where elements can be created in the future. The space must be of sufficient size and be properly aligned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">typedef</span>
        <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueType</span><span class="p">),</span>
            <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;::</span><span class="n">value</span>
        <span class="o">&gt;::</span><span class="n">type</span> <span class="n">StorageType</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">StorageType</span><span class="p">,</span> <span class="n">TSize</span><span class="o">&gt;</span> <span class="n">ArrayType</span><span class="p">;</span>

    <span class="n">ArrayType</span> <span class="n">array_</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When adding a new element to the queue, the “in-place” construction must be performed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">pushBack</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">newElem</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">spacePtr</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// get pointer to the right place</span>
        <span class="k">new</span> <span class="p">(</span><span class="n">spacePtr</span><span class="p">)</span> <span class="n">ValueType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newElem</span><span class="p">));</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When an element removed from the queue, explicit destruction must be performed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="p">...</span>
   <span class="kt">void</span> <span class="n">popBack</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">spacePtr</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// get pointer to the right place</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">elemPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">spacePtr</span><span class="p">);</span>
        <span class="n">elemPtr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span> <span class="c1">// call the destructor;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_iteration">Iteration</h4>
<div class="paragraph">
<p>There is often a need to iterate over the elements of the queue. The standard sequential random
access containers such as <a href="http://en.cppreference.com/w/cpp/container/array">std::array</a>,
<a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a> or
<a href="http://en.cppreference.com/w/cpp/container/deque">std::deque</a> may use a simple pointer (or a wrapper
class around it) as iterator because  address of every element is greater than address of its predecessor.
Incrementing a pointer during the iteration would be enough to get an access to the next element.
However, in circular queue/buffer there may be a case when address of the beginning of the queue is
greater than address of the end of the queue:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/queue_non_linearised.png" alt="Non linearised queue image">
</div>
</div>
<div class="paragraph">
<p>In this case having a simple pointer as iterator is not enough. There is a need to check a wrap-around
case when incrementing an iterator. However always using this kind of iterator may incur undesired
performance penalties. That is when “leniarisation” concept pops up. When the queue is linearised,
address of every element is greater than the address of its predecessor and simple pointer (linearised iterator)
may be used to iterate over all the elements in the queue:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/queue_linearised.png" alt="Linearised queue image">
</div>
</div>
<div class="paragraph">
<p>When the queue is not linearised, it either must be linearised (may be a bit expensive, depending on the
size of the queue) or iterate over all the elements in two stages: first on the first (top) part, then
on the second (bottom) part. The <code>StaticQueue</code> implementation in
<a href="https://github.com/arobenko/embxx">embxx</a> library provides two functions <code>arrayOne()</code> and
<code>arrayTwo()</code> that return these two ranges.</p>
</div>
<div class="paragraph">
<p>However, there may be a need to read/write data from/to the queue without worrying about the wrap-around
case. Good example of such case would be having such circular queue/buffer to contain data read from some
communication interface, such as serial port, and there is a need to deserialise 4 byte value from this
buffer. The most convenient way would be to use <code>embxx::io::readBig&lt;4&gt;(iter)</code> described previously.
To properly support this case we will need to have a bit more expensive iterator that properly handles
wrap-around when incremented and/or dereferenced. This is the reason for having two types of iterators
for <code>StaticQueue</code>: <code>LinearisedIterator</code> and <code>Iterator</code>. The former is a simple <code>typedef</code> for a pointer
which can be used only on the linearised part of the queue and the latter may be used when iterating
without any knowledge whether there is a wrap-around case during the iteration.</p>
</div>
<div class="paragraph">
<p>When defining a new custom iterator class, there is a need to properly support
<a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits">std::iterator_traits</a> for it. The traits are used
to implement functions such as <a href="http://en.cppreference.com/w/cpp/iterator/advance">std::advance</a> or
<a href="http://en.cppreference.com/w/cpp/iterator/distanc">std::distance</a>). The requirement is to define
the following internal types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Iterator</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;::</span><span class="n">difference_type</span> <span class="n">difference_type</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_copying_queues">Copying queues</h4>
<div class="paragraph">
<p>Care must be taken when copying/moving elements between the queues. The compiler is not aware of the
right type of the elements that are stored in the queue as well as number of valid elements in the queue
is unknown at compile time. When using default copy/move constructor and/or assignment operator the
compiler will generate a code that copies raw bytes in the storage space between the queues. It may work
for the basic type or POD structs, but it is not the right way to do the copying. There is a need to use
copy/move constructors in case of constructions or copy/move assignment operator in case of assignment
of the valid elements and not copy/move garbage data from unused space.</p>
</div>
<div class="paragraph">
<p>In addition to regular copy/move constructors and assignment operators, there may also be a need to
provide copy/move construction and/or copy/move assignment from the queue that contains elements
of the same type, but has different capacity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TAnySize</span><span class="o">&gt;</span>
    <span class="n">StaticQueue</span><span class="p">(</span><span class="k">const</span> <span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TAnySize</span><span class="o">&gt;&amp;</span> <span class="n">queue</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Copy all the elements from other queue</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TAnySize</span><span class="o">&gt;</span>
    <span class="n">StaticQueue</span><span class="p">(</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TAnySize</span><span class="o">&gt;&amp;&amp;</span> <span class="n">queue</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Move all the elements from other queue</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TAnySize</span><span class="o">&gt;</span>
    <span class="n">StaticQueue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TAnySize</span><span class="o">&gt;&amp;</span> <span class="n">queue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Copy all the elements from other queueu</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TAnySize</span><span class="o">&gt;</span>
    <span class="n">StaticQueue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">TAnySize</span><span class="o">&gt;&amp;&amp;</span> <span class="n">queue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Move all the elements from other queue</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optimising_code_generation">Optimising code generation</h4>
<div class="paragraph">
<p>As we all know and confirmed in <a href="#compiler_output-templates">Templates</a> chapter, any difference in the value of
template parameter will create new instantiation of executable code. It means that having multiple
queues of the same type, but different sizes may bloat the executable in an unacceptable way. The best
way to solve this problem would be defining a base class that is templated only on the type of the stored
values and implements the whole logic of the queue while the derived <code>StaticQueue</code> class will just
provide the necessary storage area and reuse (wrap) all the functions implemented in the base class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">details</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueueBase</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="k">typedef</span>
        <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueType</span><span class="p">),</span>
            <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;::</span><span class="n">value</span>
        <span class="o">&gt;::</span><span class="n">type</span> <span class="n">StorageType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">StorageType</span><span class="o">*</span> <span class="n">StorageTypePtr</span><span class="p">;</span>

    <span class="n">StaticQueueBase</span><span class="p">(</span><span class="n">StorageTypePtr</span> <span class="n">data</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
          <span class="n">capacity_</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span>
          <span class="n">startIdx_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
          <span class="n">count_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">pushBack</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="p">...</span> <span class="c1">// All other API functions</span>

<span class="nl">private:</span>
    <span class="n">StorageTypePtr</span> <span class="n">data_</span><span class="p">;</span> <span class="c1">// Pointer to storage area</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">capacity_</span><span class="p">;</span> <span class="c1">// Capacity of the storage area</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">startIdx_</span><span class="p">;</span> <span class="c1">// Index of the beginning of the queue</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count_</span><span class="p">;</span> <span class="c1">// Number of elements in the queue</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace details</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StaticQueue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">details</span><span class="o">::</span><span class="n">StaticQueueBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">details</span><span class="o">::</span><span class="n">StaticQueueBaseOptimised</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Base</span><span class="o">::</span><span class="n">StorageType</span> <span class="n">StorageType</span><span class="p">;</span>

<span class="nl">public:</span>
   <span class="n">StaticQueue</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TSize</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">pushBack</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Base</span><span class="o">::</span><span class="n">pushBack</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">...</span> <span class="c1">// Wrap all other API functions</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">StorageType</span><span class="p">,</span> <span class="n">TSize</span><span class="o">&gt;</span> <span class="n">ArrayType</span><span class="p">;</span>
    <span class="n">ArrayType</span> <span class="n">array_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are ways to optimise even more. Let&#8217;s take queues of <code>int</code> and <code>unsigned</code> values for example.
They have the same size and from the queue implementation perspective there is no difference in
handling them, so it would be a waste of code space to allow the instantiation of the same binary
code for the queue to handle both of these types. Using template specialisation tricks we may implement
queues of signed integral types to be a mere wrappers around queues that contain unsigned integral types.
Additional example would be storage of the pointers to any types. It would be wise to specialise
<code>StaticQueue</code> of pointers to be a wrapper around queue of <code>void*</code> pointers or even integral unsigned
values of the same size as pointers (such as <code>std::uint32_t</code> on 32 bit architecture or <code>std::uint64_t</code> on 64 bit architecture).</p>
</div>
<div class="paragraph">
<p>Thanks to the template specialisation there are virtually no limits to optimisations we may apply.
However I would like to remind you the well known saying “Premature optimisations are the root of all evil”.
Please avoid optimising your <code>StaticQueue</code> implementation until the need arises.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_concepts">Basic Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As already mentioned in <a href="#overview">Overview</a>, this book explains and shows examples of how to implement <strong>soft</strong>
real time systems. This chapter will explain basic concepts of asynchronous event handling as well as
how to implement required functionality without complex state machines, and/or task scheduing.</p>
</div>
<div class="sect2">
<h3 id="basic_concepts-event_loop">Event Loop</h3>
<div class="paragraph">
<p>Most bare-metal embedded products require only two modes of operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interrupt (or service) mode</p>
</li>
<li>
<p>Non-interrupt (or user) mode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The job of the code, that is executed in interrupt mode, is to respond to hardware events
(interrupts) by performing minimal job of updating various status registers and schedule
proper handling of event (if applicable) to be executed in non-interrupt mode. In most
projects the interrupt handlers are not prioritised, and the next hardware event (interrupt)
won&#8217;t be handled until the previously called interrupt handler returns, i.e. CPU is ready
to return to non-interrupt mode. Therefore, it is important for the interrupt handler to do its
job as quickly as possible.</p>
</div>
<div class="paragraph">
<p>There are multiple ways to schedule the execution of event handling code in non-interrupt mode
from code being executed in interrupt mode. One of the easiest and straightforward ones is to
have some kind of global flag that indicates that event has occurred and the processing is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="n">g_buttonPressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">gpioInterruptHandler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*button_gpio_recognised*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_buttonPressed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// infinite event processing loop</span>
        <span class="n">enableInterrupts</span><span class="p">();</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_buttonPressed</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">disableInterrupt</span><span class="p">();</span> <span class="c1">// avoid races</span>
            <span class="n">g_buttonPressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">enableInterrupts</span><span class="p">();</span>
            <span class="p">...</span> <span class="c1">// Handle button press</span>
        <span class="p">}</span>
        <span class="p">...</span>
        <span class="n">disableInterrupts</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="cm">/* no_more_events */</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">WFI</span><span class="p">();</span> <span class="c1">// “Wait for interrupt” assembler instruction,</span>
                   <span class="c1">// instruction will exit when there is pending</span>
                   <span class="c1">// interrupt.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is quite clear that this approach is not scalable, i.e. will quickly become a mess when number
of hardware events the code needs to handle grows. The events may also be handled not in the same
order they occurred, which may create undesired races and side effects on some systems.</p>
</div>
<div class="paragraph">
<p>Another widely used approach is to create a queue-like container (linked list or circular buffer)
of event IDs which are handled in the similar event loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">EventId</span>
<span class="p">{</span>
    <span class="n">EventId_ClockTick</span><span class="p">,</span>
    <span class="n">EventId_ButtonPress</span><span class="p">,</span>
    <span class="p">....</span>
<span class="p">}</span>

<span class="n">Queue</span><span class="o">&lt;</span><span class="n">EventId</span><span class="o">&gt;</span> <span class="n">events</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">gpioInterruptHandler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*button_gpio_recognised*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">events</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">EventId_ButtonPress</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// infinite event processing loop</span>
        <span class="n">enableInterrupts</span><span class="p">();</span>
        <span class="p">...</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">events</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">EventId_ClockTick</span><span class="p">:</span>
            <span class="p">...</span> <span class="c1">// handle clock tick</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">EventId_ButtonPress</span><span class="p">:</span>
            <span class="p">...</span> <span class="c1">// handle button press</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="p">...</span>
        <span class="n">disableInterrupts</span><span class="p">();</span>
        <span class="n">events</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// Remove processed event from queue</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">WFI</span><span class="p">();</span> <span class="c1">// “Wait for interrupt” assembler instruction,</span>
                   <span class="c1">// instruction will exit when there is pending interrupt.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The approach above is a bit better, it processes events in the same order they occur, but still has
its own disadvantages. Sometimes there is a need to attach some extra information for the processing
of the event. Usually it is done using global variables, which introduces some extra complexity to
the code and possibility for races. The handling of some events may have several internal stages and
require busy wait(s) during the processing. These busy waits may significantly delay the processing
of other pending events. The usual way to resolve this kind of problem is to create several state
machines, that process this kind of events in stages. Most of Real-Time OSes provide an ability
to create independent tasks (threads), that can be used to perform independent complex multiple
staged workflows while the OS performs context switching between them. Still, the code can very quickly
become too complex and difficult to maintain.</p>
</div>
<div class="paragraph">
<p>The approaches above are widely used in bare metal projects developed using C programming language.
Using C&#43;&#43; language built-in features as well as ready to use classes from STL it is possible
to simplify the complexity of the code and implement proper asynchronous handling of events,
which is easier to debug and maintain.</p>
</div>
<div class="paragraph">
<p>I would recommend using a queue of callable objects created by
<a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind()</a> expressions or
<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda functions</a>. The conventional C&#43;&#43; way
would be using <a href="http://en.cppreference.com/w/cpp/container/list">std::list</a> of
<a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> objects. However, these
classes use dynamic memory allocation and throw exceptions, which may be not suitable for every bare metal
project. Anyway, let&#8217;s just demonstrate the idea using these two classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Queue</span><span class="p">;</span>
<span class="n">Queue</span> <span class="n">handlers</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">addHandlerFromInterrupt</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// No need to disable interrupts.</span>
    <span class="n">handlers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">addHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// Protect against races with interrupt handlers</span>
    <span class="n">disableInterrupts</span><span class="p">();</span>
    <span class="n">handlers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="n">enableInterrupts</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handleButtonPressStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span><span class="c1">// Start handling of button press event</span>
    <span class="n">handleButtonPressBusyWait</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handleButtonPressBusyWait</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/* some_condition */</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handleButtonPressFinish</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// The condition is not true, need to wait,</span>
    <span class="c1">// reschedule the execution of the same function.</span>
    <span class="n">addHandler</span><span class="p">(</span>
        <span class="p">[]()</span>
        <span class="p">{</span>
             <span class="n">handleButtonPressBusyWait</span><span class="p">();</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handleButtonPressFinish</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span><span class="c1">// Finalise handling of button press event.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gpioInterruptHandler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*button_gpio_recognised*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addHandlerFromInterrupt</span><span class="p">(</span>
            <span class="p">[]()</span>
            <span class="p">{</span>
		 <span class="c1">// Will be executed in non-interrupt event loop.</span>
                 <span class="n">handleButtonPressStart</span><span class="p">();</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// infinite event processing loop</span>
        <span class="n">enableInterrupts</span><span class="p">();</span>
        <span class="p">...</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">firstHandler</span> <span class="o">=</span> <span class="n">handlers</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">firstHandler</span><span class="p">();</span> <span class="c1">// Execute scheduled callable object</span>
        <span class="p">...</span>
        <span class="n">disableInterrupts</span><span class="p">();</span>
        <span class="n">handlers</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// Remove executed callable object</span>
                              <span class="c1">// (function) from queue of handlers.</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">handlers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">WFI</span><span class="p">();</span> <span class="c1">// “Wait for interrupt” assembler instruction,</span>
                   <span class="c1">// instruction will exit when there is pending</span>
                   <span class="c1">// interrupt.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach allows having complex processing of some events with many sub-stages and busy waits
while still allowing other independent events being processed. All the handlers are executed in
the same order they were pushed to the queue. There is an ability to bind multiples additional
parameters together with the function call, which reduces a necessity to have global variables
to pass values around. There is no need to maintain a list of various event IDs, explicitly define
stages of state machine(s) or implement complex task switching between independent threads (tasks).</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s try to get rid of dynamic memory allocation and possible exceptions. The only way to achieve
this is to have a compile time constant that specifies the maximal size of the queue. The naive
implementation would be using
<a href="https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h">StaticQueue</a> of
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h">StaticFunction</a> objects described
in <a href="#basic_needs-basic_needs">Basic Needs</a> chapter. However, the
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h">StaticFunction</a> class definition
requires compile time constant to specify the size of the area to store all the data of the callable object.
It must be big enough to contain any possible callable object that will be pushed to the queue. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="o">&gt;</span>  <span class="n">Func</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="mi">1024</span><span class="o">&gt;</span> <span class="n">Queue</span><span class="p">;</span>

<span class="n">Queue</span> <span class="n">handlers</span><span class="p">;</span>
<span class="err">…</span>
<span class="n">handlers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func1</span><span class="p">,</span> <span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">));</span> <span class="c1">// Will require size of only 3 values</span>
<span class="p">...</span>
<span class="n">handlers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">func2</span><span class="p">,</span>
        <span class="n">param1</span><span class="p">,</span>
        <span class="n">param2</span><span class="p">,</span>
        <span class="n">param3</span><span class="p">,</span>
        <span class="n">param4</span><span class="p">));</span> <span class="c1">// Will require size of only 5 values</span>

<span class="n">handlers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">func3</span><span class="p">,</span>
        <span class="n">param1</span><span class="p">,</span>
        <span class="n">param2</span><span class="p">,</span>
        <span class="n">param3</span><span class="p">,</span>
        <span class="n">param4</span><span class="p">,</span>
        <span class="n">param5</span><span class="p">,</span>
        <span class="n">param6</span><span class="p">,</span>
        <span class="n">param7</span><span class="p">,</span>
        <span class="n">param8</span><span class="p">,</span>
        <span class="n">param9</span><span class="p">));</span> <span class="c1">// Will consume the whole available space.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The queue will look like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/event_loop_static_function.png" alt="Queue of StaticFunction image">
</div>
</div>
<div class="paragraph">
<p>It is quite clear that lots of space may be wasted and this approach must be optimised. What if we
could push the callable object to the queue one after another regardless of their actual size with a
bit of extra space overhead (such as pointer to v-table), that will help us to retrieve size of the
object at runtime and remove appropriate number of bytes from such queue after the callable object did its job?</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/event_loop_optimised.png" alt="Optimised queue image">
</div>
</div>
<div class="paragraph">
<p>It looks much better. The space consumption is much more efficient.</p>
</div>
<div class="paragraph">
<p>To properly support this type of queue we must:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>implement polymorphic behaviour when calling every handler with same interface.</p>
</li>
<li>
<p>implement polymorphic behaviour to retrieve the size of single handler in order to know how many
bytes are to be removed from the queue after the handler has been called.</p>
</li>
<li>
<p>properly handle wrap-around cases when the pushed handler cannot fit into the area between the end of
the queue and end of the allocated space.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The code of required classes will be like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Task</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Task</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">getSize</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1U</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTask</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TaskBound</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Task</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="c1">// Size is minimal number of elements of size equal to sizeof(Task)</span>
    <span class="c1">// that will be able to store this TaskBound object</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Size</span> <span class="o">=</span>
        <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TaskBound</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTask</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                                                     <span class="k">sizeof</span><span class="p">(</span><span class="n">Task</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="n">TaskBound</span><span class="p">(</span><span class="k">const</span> <span class="n">TTask</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">task_</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="n">TaskBound</span><span class="p">(</span><span class="n">TTask</span><span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">task_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskBound</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">getSize</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">task_</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TTask</span> <span class="n">task_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of the Queue type will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span>
    <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">Task</span><span class="p">),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;::</span><span class="n">value</span>
   <span class="o">&gt;::</span><span class="n">type</span> <span class="n">ArrayElemType</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ArraySize</span> <span class="o">=</span> <span class="n">TSize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Task</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">ArrayElemType</span><span class="p">,</span> <span class="n">ArraySize</span><span class="o">&gt;</span> <span class="n">Queue</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TSize</code> is a template parameter that specifies maximum size (in bytes) of the queue storage area.</p>
</div>
<div class="paragraph">
<p>The code of pushing new handler to the queue will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTask</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="nf">addHandler</span><span class="p">(</span><span class="n">TTask</span><span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">TaskBound</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTask</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">TaskBoundType</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">TaskBoundType</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
        <span class="s">"Alignment of TaskBound must be same as alignment of Task"</span><span class="p">);</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">requiredQueueSize</span> <span class="o">=</span> <span class="n">TaskBoundType</span><span class="o">::</span><span class="n">Size</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">placePtr</span> <span class="o">=</span> <span class="n">getAllocPlace</span><span class="p">(</span><span class="n">requiredQueueSize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">placePtr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">new</span> <span class="p">(</span><span class="n">placePtr</span><span class="p">)</span> <span class="n">TaskBoundType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTask</span><span class="o">&gt;</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that job of <code>getAllocPlace()</code> function is to make sure that continuous storage area that is
able to store the required callable object is created (by resizing the queue) and return pointer to this area.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">ArrayElemType</span><span class="o">*</span> <span class="nf">getAllocPlace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">requiredQueueSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">invalidIter</span> <span class="o">=</span> <span class="n">queue_</span><span class="p">.</span><span class="n">invalidIter</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">queue_</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">-</span> <span class="n">queue_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">requiredQueueSize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">curSize</span> <span class="o">=</span> <span class="n">queue_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue_</span><span class="p">.</span><span class="n">isLinearised</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span>
                <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">queue_</span><span class="p">.</span><span class="n">arrayTwo</span><span class="p">().</span><span class="n">second</span><span class="p">,</span> <span class="n">invalidIter</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">requiredQueueSize</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">queue_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">curSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">placePtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
                <span class="k">new</span> <span class="p">(</span><span class="n">placePtr</span><span class="p">)</span> <span class="n">Task</span><span class="p">();</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">queue_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">curSize</span> <span class="o">+</span> <span class="n">requiredQueueSize</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">queue_</span><span class="p">[</span><span class="n">curSize</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case of wrap-around, when there is not enough space between the end of the queue and end of its
storage area, number of simple <code>Task</code> objects which do nothing (the body of exec() function is empty)
are pushed to fill the space till the end of storage area to make the queue non-linearised, which in
turn will allow creation of continuous area of required size in the second half of the circular queue.</p>
</div>
<div class="paragraph">
<p>The event handling loop will be something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// Get an access pointer to next handler</span>
    <span class="k">auto</span> <span class="n">taskPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">sizeToRemove</span> <span class="o">=</span> <span class="n">taskPtr</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>

    <span class="c1">// Execute the handler while allowing interrutps</span>
    <span class="n">enableInterrupts</span><span class="p">();</span>
    <span class="n">taskPtr</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">();</span>

    <span class="c1">// Remove the handler information from the queue</span>
    <span class="n">taskPtr</span><span class="o">-&gt;~</span><span class="n">Task</span><span class="p">();</span>
    <span class="n">disableInterrupts</span><span class="p">();</span>
    <span class="n">queue_</span><span class="p">.</span><span class="n">popFront</span><span class="p">(</span><span class="n">sizeToRemove</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The only remaining thing is to create a convenient and generic interface to be able to add new handlers for
execution from both interrupt and non-interrupt contexts.</p>
</div>
<div class="sect3">
<h4 id="_analogy_with_threads">Analogy with Threads</h4>
<div class="paragraph">
<p>Before diving into implementation of such interface, I&#8217;d like to make an analogy between
interrupt/non-interrupt execution modes and two threads. The inter-threads communication is managed using
locks (such as <a href="http://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>) and condition variables (such as
<a href="http://en.cppreference.com/w/cpp/thread/condition_variable_any">std::condition_variable_any</a>). Using this
analogy the handlers execution loop (executed in non-interrupt thread) can be implemented like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock_</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable_any</span> <span class="n">cond_</span><span class="p">;</span>
<span class="p">...</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">taskPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="k">auto</span> <span class="n">sizeToRemove</span> <span class="o">=</span> <span class="n">taskPtr</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
        <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

        <span class="c1">// Executed with interrupts enabled</span>
        <span class="n">taskPtr</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">();</span>
        <span class="n">taskPtr</span><span class="o">-&gt;~</span><span class="n">Task</span><span class="p">();</span>

        <span class="n">lock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">queue_</span><span class="p">.</span><span class="n">popFront</span><span class="p">(</span><span class="n">sizeToRemove</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Still locked prior to wait</span>
    <span class="n">cond_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
    <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And adding new execution handler from any thread can be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTask</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="nf">addHandler</span><span class="p">(</span><span class="n">TTask</span><span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lock_</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
   <span class="p">...</span> <span class="c1">// adding handler functionality</span>
   <span class="n">cond_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span> <span class="c1">// notify the condition variable</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we think about interrupt and non-interrupt execution modes as two threads, the locking in non-interrupt
thread is equivalent to disabling interrupts; and waiting for condition variable to be notified is equivalent
for waiting for interrupts (using <code>WFI</code> or <code>WFE</code> instructions in ARM architecture) while notification can
be automatic due to pending interrupts or implemented using <code>SEV</code> instruction. However, our interrupt
and non-interrupt mode threads  differ slightly from conventional threads. The non-interrupt mode one can be
interrupted at any time by interrupt mode, while the interrupt mode “thread” won&#8217;t be interrupted and doesn&#8217;t
actually need to protect itself from other thread&#8217;s intervention.</p>
</div>
<div class="paragraph">
<p>The whole logic of event handling loop in non-interrupt context described above is generic except locking
(disabling interrupts) and waiting for new handlers to be added (waiting for interrupts) which are platform
and architecture specific. As I&#8217;ve mentioned before, the whole idea of using C&#43;&#43; instead of C
in bare metal development is to be able to write and reuse generic code while providing minimal platform
specific hardware control functionality. The <a href="https://github.com/arobenko/embxx">embxx</a> library provides
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h">EventLoop</a> class that receives the
locking and condition variable classes as template parameters and manages safe addition of new handlers
and in-order execution of the latter in non-interrupt context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">The</span> <span class="k">class</span> <span class="nc">definition</span> <span class="n">looks</span> <span class="n">like</span> <span class="k">this</span><span class="o">:</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tlock</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TCond</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EventLoop</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TLock</code> class must expose the following public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">PlatformLock</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Locks out interrupt "thread". The function is called</span>
    <span class="c1">// in non-interrupt context</span>
    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{...}</span>

    <span class="c1">// Restore previous state changed by "lock()" function, i.e.</span>
    <span class="c1">// allow interrupts if they were disabled by lock().</span>
    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">{...}</span>

    <span class="c1">// Same as lock(), but will be called when new handler is about to</span>
    <span class="c1">// be added from interrupt handler. In normal case it should be an</span>
    <span class="c1">// empty function, unless the interrupts are prioritised and there</span>
    <span class="c1">// is a need to disable other interrupts from an interrupt handler</span>
    <span class="kt">void</span> <span class="n">lockInterruptCtx</span><span class="p">()</span> <span class="p">{...}</span>

    <span class="c1">// Same as unlock, but will be called in interrupt context. Should</span>
    <span class="c1">// also be empty function when interrupts are not prioritised.</span>
    <span class="kt">void</span> <span class="n">unlockInterruptCtx</span><span class="p">()</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TCond</code> class must expose the following public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">PlatformCond</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Receives the reference to lockable object that is locked</span>
    <span class="c1">// (has lock() and unlock() member functions) and</span>
    <span class="c1">// responsible to release the lock if needed and wait for</span>
    <span class="c1">// notifications from other thread(s). After the notification</span>
    <span class="c1">// occurs it must re-acquire the lock prior to returning.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TLock</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">wait</span><span class="p">(</span><span class="n">TLock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// This function is used to notify condition that wait should</span>
    <span class="c1">// be terminated.</span>
    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The example of such classes for Raspberry Pi platform may be found
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/EventLoopDevices.h">here</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">InterruptLock</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">InterruptLock</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">flags_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"mrs %0, cpsr"</span> <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">flags_</span><span class="p">));</span> <span class="c1">// store flags</span>
        <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"cpsid i"</span><span class="p">);</span> <span class="c1">// disable interrupts</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">IntMask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Was previously enabled</span>
            <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"cpsie i"</span><span class="p">);</span> <span class="c1">// enable interrupts</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">lockInterruptCtx</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">unlockInterruptCtx</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">volatile</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">flags_</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">IntMask</span> <span class="o">=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WaitCond</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TLock</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">wait</span><span class="p">(</span><span class="n">TLock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// no need to unlock (re-enable interrupts)</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"wfi"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do, pending interrupt will cause wfi</span>
        <span class="c1">// to exit even with interrupts disabled</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h">EventLoop</a> class exposes the following public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tlock</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TCond</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EventLoop</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="c1">/// @brief Post new handler for execution.</span>
    <span class="c1">/// @details Acquires regular context lock. The task is added to</span>
    <span class="c1">///          the execution queue. If the execution queue is empty</span>
    <span class="c1">///          before the new handler is added, the condition</span>
    <span class="c1">///          variable is signalled by calling its notify() member</span>
    <span class="c1">///          function.</span>
    <span class="c1">/// @param[in] task R-value reference to new handler functor.</span>
    <span class="c1">/// @return true in case the handler was successfully posted,</span>
    <span class="c1">///         false if there is not enough space in the execution</span>
    <span class="c1">///         queue.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTask</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">post</span><span class="p">(</span><span class="n">TTask</span><span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">);</span>

    <span class="c1">/// @brief Post new handler for execution from interrupt context.</span>
    <span class="c1">/// @details Acquires interrupt context lock. The task is added to</span>
    <span class="c1">///          the execution queue. If the execution queue is empty</span>
    <span class="c1">///          before the new handler is added, the condition variable</span>
    <span class="c1">///          is signalled by calling its notify() member function.</span>
    <span class="c1">/// @param[in] task R-value reference to new handler functor.</span>
    <span class="c1">/// @return true in case the handler was successfully posted, false</span>
    <span class="c1">///         if there is not enough space in the execution queue.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTask</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">postInterruptCtx</span><span class="p">(</span><span class="n">TTask</span><span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">);</span>

    <span class="c1">/// @brief Event loop execution function.</span>
    <span class="c1">/// @details The function keeps executing posted handlers until</span>
    <span class="c1">///          none are left. When execution queue becomes empty the</span>
    <span class="c1">///          wait(...) member function of the condition variable</span>
    <span class="c1">///          gets called to execute blocking wait for new handlers.</span>
    <span class="c1">///          When new handler is added, the condition variable will</span>
    <span class="c1">///          be signalled and blocking wait is expected to be</span>
    <span class="c1">///          terminated to continue execution of the event loop.</span>
    <span class="c1">///          This function never exits unless stop() was called to</span>
    <span class="c1">///          terminate the execution. After stopping the main</span>
    <span class="c1">///          loop, use reset() member function to enable the loop</span>
    <span class="c1">///          to be executed again.</span>
    <span class="kt">void</span> <span class="n">run</span><span class="p">();</span>

    <span class="c1">/// @brief Stop execution of the event loop.</span>
    <span class="c1">/// @details The execution may not be stopped immediately. If there</span>
    <span class="c1">///          is an event handler being executed, the loop will be</span>
    <span class="c1">///          stopped after the execution of the handler is finished.</span>
    <span class="kt">void</span> <span class="n">stop</span><span class="p">();</span>

    <span class="c1">/// @brief Reset the state of the event loop.</span>
    <span class="c1">/// @details Clear the queue of registered event handlers and</span>
    <span class="c1">///          resets the "stopped" flag to allow new event loop</span>
    <span class="c1">///          execution.</span>
    <span class="kt">void</span> <span class="n">reset</span><span class="p">();</span>
<span class="p">}</span><span class="o">:</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;ll leave the implementation of the functions above as an exercise to the reader. Don&#8217;t
forget to call <code>notify()</code> member function of condition variable when adding new handler to
the empty queue.</p>
</div>
<div class="paragraph">
<p>If needed, the reference implementation can be found
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_busy_loops">Busy Loops</h4>
<div class="paragraph">
<p>The event loop described above is an easy and convenient way to implement soft real-time systems.
However, the main rule with such architecture is: <strong>DON&#8217;T DO BUSY LOOPS!</strong> It means, if there is a
real need to perform a busy wait before proceeding to the next stage, do it by letting other events
being handled as well. The <code>EventLoop</code> class also provides <code>busyWait()</code> member function that does exactly that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tlock</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TCond</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">EventLoop</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="c1">/// @brief Perform busy wait.</span>
    <span class="c1">/// @details Executes busy wait while allowing other event handlers</span>
    <span class="c1">///          posted by interrupt handlers being processed.</span>
    <span class="c1">/// @tparam TPred Predicate class type, must define</span>
    <span class="c1">///         @code bool operator()(); @endcode</span>
    <span class="c1">///         that return true in case busy wait must be terminated.</span>
    <span class="c1">/// @tparam TFunc Functor class that will be executed when wait is</span>
    <span class="c1">///         complete. It must define</span>
    <span class="c1">///         @code void operator()(); @endcode</span>
    <span class="c1">/// @param pred Any type of reference to predicate object</span>
    <span class="c1">/// @param func Any type of reference to "wait complete" function.</span>
    <span class="c1">/// @pre The event loop must have enough space to repost the call</span>
    <span class="c1">///      to busyWait(). Note that there is no wait to notify the</span>
    <span class="c1">///      caller if post operation fails. In debug compilation mode</span>
    <span class="c1">///      there will be an assertion failure in case call to post()</span>
    <span class="c1">///      returned false, in release compilation mode the failure</span>
    <span class="c1">///      will be silent.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TPred</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">busyWait</span><span class="p">(</span><span class="n">TPred</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">post</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">post</span><span class="p">(</span>
            <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">func</span><span class="p">]()</span>
            <span class="p">{</span>
                <span class="n">busyWait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
            <span class="p">});</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basic_concepts-device_driver_component">Device-Driver-Component</h3>
<div class="paragraph">
<p>Now, after understanding what the event loop is and how to implement it in C&#43;&#43;,
I&#8217;d like to describe <strong>Device-Driver-Component</strong> stack concept before proceeding to
practical examples.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/device_driver_component.png" alt="Image: Device-Driver-Component Stack">
</div>
</div>
<div class="paragraph">
<p>The <strong>Device</strong> is a platform specific peripheral(s) control layer. Sometimes it is called HAL -
<strong>H</strong>ardware <strong>A</strong>bstraction <strong>L</strong>ayer. It has an access to platform specific peripheral control registers.
Its job is to implement predefined interface required by upper <strong>Driver</strong> layer, handle the relevant
interrupts and report them to the <strong>Driver</strong> via callbacks.</p>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> is a generic platform independent layer. Its job is to receive requests for asynchronous
operation from the <strong>Component</strong> layer and forward the request to the <strong>Device</strong>. It is also responsible
for receiving notifications about the interrupts from the <strong>Device</strong> via callbacks, perform minimal
processing of the hardware event if necessary and schedule the execution of proper event handling
callback from the <strong>Component</strong> in non interrupt context using <a href="#basic_concepts-event_loop">Event Loop</a>.</p>
</div>
<div class="paragraph">
<p>The <strong>Component</strong> is a generic or product specific layer that works fully in event loop (non-interrupt)
context. It initiates asynchronous operations using <strong>Driver</strong> while providing a callback object to be
called in event loop context when the asynchronous operation is complete.</p>
</div>
<div class="paragraph">
<p>There are several main operations required for any asynchronous event handling:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the operation.</p>
</li>
<li>
<p>Complete the operation.</p>
</li>
<li>
<p>Cancel the operation.</p>
</li>
<li>
<p>Suspend the operation.</p>
</li>
<li>
<p>Resume suspended operation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All the peripherals described in <a href="#peripherals-peripherals">Peripherals</a> chapter will follow the same scheme
for these operations with minor changes, such as having extra parameters or intermediate stages.</p>
</div>
<div class="sect3">
<h4 id="_starting_asynchronous_operation">Starting Asynchronous Operation</h4>
<div class="imageblock">
<div class="content">
<img src="images/async_op_start.png" alt="Image: Starting Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>Any non-interrupt context operation is initiated from some event handler executed by the
<a href="#basic_concepts-event_loop">Event Loop</a> or from the <code>main()</code> function before the event loop started
its execution. The handler being executed invokes some function in some <strong>Component</strong>, which
requests the <strong>Driver</strong> to perform some asynchronous operation while providing a callback
object to be executed when such operation is complete. The <strong>Driver</strong> stores the provided
callback object and other parameters in its internal data structures, then forwards the
request to the <strong>Device</strong>, which configures the hardware accordingly and enables all the required interrupts.</p>
</div>
</div>
<div class="sect3">
<h4 id="_completing_asynchronous_operation">Completing Asynchronous Operation</h4>
<div class="paragraph">
<p>The first entity, that is aware of asynchronous operation completion, is <strong>Device</strong> when
appropriate interrupt occurs. It must report the completion to the <strong>Driver</strong> somehow.
As was described earlier, the <strong>Device</strong> is a platform specific layer that resides at the
bottom of the <strong>Device-Driver-Component</strong> stack and is not aware of the generic <strong>Driver</strong> layer
that uses it. The <strong>Device</strong> must provide a way to set an operation completion report object. The
<strong>Driver</strong> will usually assign such object during construction/initialisation stage:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_callback.png" alt="Image: Assigning callback">
</div>
</div>
<div class="paragraph">
<p>When the expected interrupt occurs, the <strong>Device</strong> reports operation completion to the
<strong>Driver</strong>, which in turn schedules execution of the callback object from the <strong>Component</strong>
in non-interrupt context using <a href="#basic_concepts-event_loop">Event Loop</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_complete.png" alt="Image: Completing Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>Note that the operation may fail, due to some hardware faults, This is the reason to have
<code>status</code> parameter reporting success and/or error condition in both callback invocations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_canceling_asynchronous_operation">Canceling Asynchronous Operation</h4>
<div class="paragraph">
<p>There must be an ability to cancel asynchronous operations in progress. For example some
<strong>Component</strong> activates asynchronous operation request on some hardware peripheral together
with asynchronous wait request to the timer to measure the operation timeout. If timeout
callback is invoked first, then there is a need to cancel the outstanding asynchronous
operation. Or the opposite, once the read is successful, the timeout measure should be canceled.
However, the cancellation may be a bit tricky. One of the main requirements for asynchronous
events handling is that the <strong>Component</strong>'s callback <strong>MUST</strong> be called and called only <strong>ONCE</strong>.
It creates a situation when cancellation may become unsuccessful. For instance, the callback of
the asynchronous operation was posted for execution in Event Loop, but hasn&#8217;t been executed by the
latter yet. It brings us to the necessity to provide an indication whether the cancellation request
was successful. Simple boolean return value is enough.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_cancel1.png" alt="Image: Canceling Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>When the cancellation is successful the <strong>Component</strong>'s callback object is invoked with <code>status</code>
specifying that operation was <code>Aborted</code>.</p>
</div>
<div class="paragraph">
<p>One possible case of unsuccessful cancellation is when callback was posted for execution in event
loop, but hasn&#8217;t been executed yet when cancellation is attempted. In this case <strong>Driver</strong> is aware
that there is no pending asynchronous operation and can return <code>false</code> immediately.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_cancel2.png" alt="Image: Canceling Asynchronous Operation Unsuccessful1">
</div>
</div>
<div class="paragraph">
<p>Another possible case of unsuccessful cancellation is when completion interrupt occurs in
the middle of cancellation request:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_cancel3.png" alt="Image: Canceling Asynchronous Operation Unsuccessful2">
</div>
</div>
<div class="paragraph">
<p>In this case the <strong>Device</strong> must be able to handle such race condition appropriately, by temporarily
disabling interrupts before checking whether the completion callback was executed. The <strong>Driver</strong>
must also be able to handle interrupt context execution in the middle on non-interrupt one.</p>
</div>
</div>
<div class="sect3">
<h4 id="_suspend_resume_asynchronous_operation">Suspend / Resume Asynchronous Operation</h4>
<div class="paragraph">
<p>There may be a <strong>Driver</strong>, that is required to support multiple asynchronous operations at the same
time, while managing internal queue of such requests and issuing them one by one to the <strong>Device</strong>.
In this case there is a need to prevent "operation complete" callback being invoked in interrupt
mode context, while trying to access the internal data structures in the event loop (non-interrupt)
context. The <strong>Device</strong> must provide both <code>suspendOp()</code> and <code>resumeOp()</code> to suppress invocation of the
callback and allow it back again respectively. Usually suspension means disabling the interrupts
without stopping current operation, while resume means re-enabling them again.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_suspend.png" alt="Image: Suspending Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>Note that the <code>suspendOp()</code> request must also indicate whether the suspension was successful or the
completion callback has been already invoked in interrupt mode, just like with the cancellation.
After the operation being successfully suspended, it must be either <strong>resumed</strong> or <strong>canceled</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_device_function_invocation_context"><strong>Device</strong> Function Invocation Context</h4>
<div class="paragraph">
<p>Let&#8217;s think about the case when <strong>Driver</strong> supports multiple asynchronous operations at the same
time and queuing them internally while issueing start requests to the <strong>Device</strong> one by one.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/async_op_context.png" alt="Image: Starting Multiple Asynchronous Operations">
</div>
</div>
<div class="paragraph">
<p>The reader may notice that the <code>startOp()</code> member function of the <strong>Device</strong> was invoked in event
loop (non-interrupt) context while the second time it was in interrupt context right after the
completion of the first operation was reported. There may be a need for the <strong>Device</strong>'s implementation
to differentiate between these calls.</p>
</div>
<div class="paragraph">
<p>One of the ways to do so is to have different names and make the <strong>Driver</strong> use them depending on
the current execution context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">startOp</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">startOpInterruptCtx</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way is to use a
<a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">tag dispatching idiom</a>,
which I decided to use in <a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
<div class="paragraph">
<p>It defines two extra tag structs in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/device/context.h">embxx/device/context.h</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">embxx</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">device</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">context</span>
<span class="p">{</span>

<span class="c1">// Event loop context tag class.</span>
<span class="k">struct</span> <span class="n">EventLoop</span> <span class="p">{};</span>

<span class="c1">// Interrupt context tag class.</span>
<span class="k">struct</span> <span class="n">Interrupt</span> <span class="p">{};</span>

<span class="p">}</span> <span class="c1">// namespace context</span>

<span class="p">}</span> <span class="c1">// namespace device</span>

<span class="p">}</span> <span class="c1">// namespace embxx</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, almost every member function defined by <strong>Device</strong> class has to specify extra tag parameter
indicating context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopCtx</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptCtx</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">startOp</span><span class="p">(</span><span class="n">EventLoopCtx</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> <span class="c1">// unused parameter</span>
        <span class="p">...</span> <span class="c1">// Perform operation when called in event loop context</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">startOp</span><span class="p">(</span><span class="n">InterruptCtx</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> <span class="c1">// unused parameter</span>
        <span class="p">...</span> <span class="c1">// Perform operation when called in interrupt context</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> class will invoke the <strong>Device</strong> functions using relevant temporary context object
passed as the last parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopCtx</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptCtx</span><span class="p">;</span>

    <span class="c1">// Invoked by some Component object in Event Loop Context</span>
    <span class="kt">void</span> <span class="n">asyncOp</span><span class="p">(...)</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">startOp</span><span class="p">(</span><span class="n">EventLoopCtx</span><span class="p">());</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="nl">private:</span>

   <span class="c1">// Some registered event callback handler,</span>
   <span class="c1">// invoked in interrupt context</span>
   <span class="kt">void</span> <span class="n">interruptCallbackHandler</span><span class="p">()</span>
   <span class="p">{</span>
       <span class="p">...</span>
       <span class="n">device_</span><span class="p">.</span><span class="n">startOp</span><span class="p">(</span><span class="n">InterruptCtx</span><span class="p">());</span>
   <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If some function needs to be called only in, say <code>EventLoop</code> context, and not supported in
<code>Interrupt</code> context, then it is enough to implement only supported variant. If <strong>Driver</strong> layer
tries to invoke the function with unsupported context tag parameter, the compilation will fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopCtx</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">cancelOp</span><span class="p">(</span><span class="n">EventLoopCtx</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> <span class="c1">// unused parameter</span>
        <span class="p">...</span> <span class="c1">// Cancel recent operation</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If there is no need to differentiate between the contexts the function is invoked in, then
it is quite easy to unify them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TContext</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">startOp</span><span class="p">(</span><span class="n">TContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> <span class="c1">// unused parameter</span>
        <span class="n">startOpInternal</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">startOpInternal</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reporting_errors">Reporting Errors</h4>
<div class="paragraph">
<p>When issuing asynchronous operation request to the <strong>Driver</strong> and/or <strong>Component</strong>, there must be
a way to report success / failure status of the operation, and if it failed provide some extra
information about the reason of the failure. Providing such information as first parameter to
the callback functor object is a widely used convention among the developers.</p>
</div>
<div class="paragraph">
<p>In most cases, the numeric value of error code is good enough.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx">embxx</a> library provides a short list of such values in
enumeration class defined in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorCode.h">embxx/error/ErrorCode.h</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">embxx</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">error</span>
<span class="p">{</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span>
<span class="p">{</span>
    <span class="n">Success</span><span class="p">,</span> <span class="c1">///&lt; Successful completion of operation.</span>
    <span class="n">Aborted</span><span class="p">,</span> <span class="c1">///&lt; The operation was cancelled/aborted.</span>
    <span class="n">BufferOverflow</span><span class="p">,</span> <span class="c1">/// The buffer is full with read termination condition being false</span>
    <span class="n">HwProtocolError</span><span class="p">,</span> <span class="c1">///&lt; Hardware peripheral reported protocol error.</span>
    <span class="n">Timeout</span><span class="p">,</span> <span class="c1">///&lt; The operation takes too much time.</span>
    <span class="n">NumOfStatuses</span> <span class="c1">///&lt; Number of available statuses. Must be last</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace error</span>

<span class="p">}</span>  <span class="c1">// namespace embxx</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a wrapper class around the <code>embxx::error::ErrorCode</code>, called
<code>embxx::error::ErrorStatus</code> (defined in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorStatus.h">embxx/error/ErrorStatus.h</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">embxx</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">error</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TErrorCode</span> <span class="o">=</span> <span class="n">ErrorCode</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ErrorStatusT</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">/// @brief Error code enum type</span>
    <span class="k">typedef</span> <span class="n">TErrorCode</span> <span class="n">ErrorCodeType</span><span class="p">;</span>

    <span class="c1">/// @brief Default constructor.</span>
    <span class="c1">/// @details The code value is 0, which is "success".</span>
    <span class="n">ErrorStatusT</span><span class="p">();</span>

    <span class="c1">/// @brief Constructor</span>
    <span class="c1">/// @details This constructor may be used for implicit</span>
    <span class="c1">///          construction of error status object out</span>
    <span class="c1">///          of error code value.</span>
    <span class="c1">/// @param code Numeric error code value.</span>
    <span class="n">ErrorStatusT</span><span class="p">(</span><span class="n">ErrorCodeType</span> <span class="n">code</span><span class="p">);</span>

    <span class="c1">/// @brief Copy constructor is default</span>
    <span class="n">ErrorStatusT</span><span class="p">(</span><span class="k">const</span> <span class="n">ErrorStatusT</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">/// @brief Destructor is default</span>
    <span class="o">~</span><span class="n">ErrorStatusT</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">/// @brief Copy assignment is default</span>
    <span class="n">ErrorStatusT</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ErrorStatusT</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">/// @brief Retrieve error code value.</span>
    <span class="k">const</span> <span class="n">ErrorCodeType</span> <span class="n">code</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">/// @brief boolean conversion operator.</span>
    <span class="c1">/// @details Returns true if error code is not equal 0,</span>
    <span class="c1">///          i.e. any error will return true, success</span>
    <span class="c1">///          value will return false.</span>
    <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">/// @brief Same as !(static_cast&lt;bool&gt;(*this)).</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">ErrorCodeType</span> <span class="n">code_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">ErrorStatusT</span><span class="o">&lt;</span><span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">ErrorStatus</span><span class="p">;</span>

<span class="p">}</span>  <span class="c1">// namespace error</span>

<span class="p">}</span>  <span class="c1">// namespace embxx</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It allows implicit conversion from <code>embxx::error::ErrorCode</code> to <code>embxx::error::ErrorStatus</code>
and convenient evaluation whether error has occurred in <code>if</code> sentences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span> <span class="n">es</span><span class="p">;</span>
<span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span> <span class="c1">// No error</span>
<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="cm">/* some condition */</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">es</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">BufferOverflow</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">es</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// Error occurred, access the arror code by calling es.code()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By convention every callback function provided with any asynchronous request to any <strong>Driver</strong>
and/or <strong>Component</strong> implemented in <a href="https://github.com/arobenko/embxx">embxx</a> library will
receive <code>const embxx::error::ErrorStatus&amp;</code> as its first argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* some other parameters */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">Aborted</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// Nothing to do</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">es</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Error occurred</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span> <span class="c1">// Success</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cooperation">Cooperation</h4>
<div class="paragraph">
<p>As it is seen in the charts above, the <strong>Driver</strong> must have an access to the <strong>Device</strong> as well as
<strong>Event Loop</strong> objects. However, the former is not aware of the exact type of the latter. In order
to write fully generic code, the <strong>Device</strong> and <strong>Event Loop</strong> types must be provided as template arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// During the construction store references to Device</span>
    <span class="c1">// and Event Loop objects.</span>
    <span class="n">MyDriver</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
        <span class="n">el_</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>

    <span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device_</span><span class="p">;</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Component</strong> needs an access only to the <strong>Device</strong> and maybe <strong>Event Loop</strong>. The reference to
the latter may be retrieved from the <strong>Device</strong> object itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">getEventLoop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">el_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyComponent</span><span class="p">(</span><span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">driver_</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">someFunc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">driver_</span><span class="p">.</span><span class="n">getEventLoop</span><span class="p">();</span>
        <span class="n">el</span><span class="p">.</span><span class="n">post</span><span class="p">(...);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_storing_callback_object">Storing Callback Object</h4>
<div class="paragraph">
<p>The <strong>Driver</strong> needs to provide a callback object to the <strong>Device</strong> to be called when appropriate
interrupt occurs. The <strong>Component</strong> also provides a callback object to be invoked in non-interrupt
context when the asynchronous operation is complete, aborted or terminated due to some error condition.
These callback objects need to be stored somewhere. The best way to do so in conventional
C&#43;&#43; is using <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncOp</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">callbackObj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">callback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callbackObj</span><span class="p">);</span>
        <span class="p">...</span> <span class="c1">// Start the operation</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;&gt;</span> <span class="n">CallbackType</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">opCompleteInterruptCallback</span><span class="p">(</span><span class="kt">void</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Complete the operation</span>
        <span class="n">el_</span><span class="p">.</span><span class="n">postInterruptCtx</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">callback_</span><span class="p">),</span> <span class="n">es</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">EventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
    <span class="n">CallbackType</span> <span class="n">callback_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two problems with using <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>:
exceptions and dynamic memory allocation. It is possible to suppress the usage of exceptions by
making sure that function object is never invoked without proper object being assigned to it, and by
overriding appropriate <code>__throw_*</code> function(s) to remove exception handling code from binary image
(described in <a href="#compiler_output-exceptions">Exceptions</a> chapter). However, it is impossible to get rid of
dynamic memory allocation in this case, which reduces number of bare metal products the <strong>Driver</strong> code
can be reused in, i.e. it makes the <strong>Driver</strong> class not fully generic.</p>
</div>
<div class="paragraph">
<p>The problem is resolved by defining the callback storage type as a template parameter to the <strong>Driver</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TCallbackType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="p">...</span>
    <span class="n">TCallbackType</span> <span class="n">callback_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For projects that allow dynamic memory allocation <code>std::function&lt;&#8230;&#8203;&gt;</code> can be passed, for
others <code>embxx::util::StaticFunction&lt;&#8230;&#8203;&gt;</code> or similar must be used.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="peripherals-peripherals">Peripherals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It this chapter I will describe and give multiple examples of how to drive and control multiple
hardware peripherals while using <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model in conjunction
with <a href="#basic_concepts-event_loop">Event Loop</a>.</p>
</div>
<div class="paragraph">
<p>All the generic, platform independent code provided here is implemented as part of
<a href="https://github.com/arobenko/embxx">embxx</a> library while platform (Raspberry Pi) specific code is
taken from <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project.</p>
</div>
<div class="paragraph">
<p>All the platform specific peripheral control classes reside in
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/device">src/device</a> directory.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app">src/app</a> directory contains several simple
applications, such as flashing the led or responding to button presses.</p>
</div>
<div class="paragraph">
<p>There are also common <strong>Component</strong> classes shared between the applications. They reside in
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/component">src/component</a> directory.</p>
</div>
<div class="paragraph">
<p>In order to compile all the applications please follow the instructions described in
<a href="#overview-contents">Contents of This Book</a>.</p>
</div>
<div class="sect2">
<h3 id="_function_configuration">Function Configuration</h3>
<div class="paragraph">
<p>In ARM platform every pin needs to be configured as either gpio input, gpio output or having one of
several alternative functions the microcontroller supports. The <code>device::Function</code> class defined in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.h">src/device/Function.h</a> and
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.cpp">src/device/Function.cpp</a>
implements simple interface which allows every <strong>Device</strong> class configure the pins it uses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Function</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">FuncSel</span> <span class="p">{</span>
        <span class="n">Input</span><span class="p">,</span>  <span class="c1">// b000</span>
        <span class="n">Output</span><span class="p">,</span> <span class="c1">// b001</span>
        <span class="n">Alt5</span><span class="p">,</span>   <span class="c1">// b010</span>
        <span class="n">Alt4</span><span class="p">,</span>   <span class="c1">// b011</span>
        <span class="n">Alt0</span><span class="p">,</span>   <span class="c1">// b100</span>
        <span class="n">Alt1</span><span class="p">,</span>   <span class="c1">// b101</span>
        <span class="n">Alt2</span><span class="p">,</span>   <span class="c1">// b110</span>
        <span class="n">Alt3</span>    <span class="c1">// b111</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">PinIdxType</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">NumOfLines</span> <span class="o">=</span> <span class="mi">54</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">configure</span><span class="p">(</span><span class="n">PinIdxType</span> <span class="n">idx</span><span class="p">,</span> <span class="n">FuncSel</span> <span class="n">sel</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Every implemented <strong>Device</strong> class will receive reference to <code>Function</code> object in its constructor
and will have to use it to configure the pins as required.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interrupts_management">Interrupts Management</h3>
<div class="paragraph">
<p>There is one more componenet that every <strong>Device</strong> will use. It&#8217;s <code>device::InterruptMgr</code> defined in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h">src/device/InterruptMgr.h</a>.
The main responsibility of the object of this class is to control global level interrupts, register
interrupt handlers from various <strong>Device</strong>s and invoke the appropriate handler when interrupt occurs.</p>
</div>
<div class="paragraph">
<p>The interface of the <code>device::InterruptMgr</code> is defined as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">THandler</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InterruptMgr</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">THandler</span> <span class="n">HandlerFunc</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">IrqId</span> <span class="p">{</span>
        <span class="n">IrqId_Timer</span><span class="p">,</span>
        <span class="n">IrqId_AuxInt</span><span class="p">,</span>
        <span class="n">IrqId_Gpio1</span><span class="p">,</span>
        <span class="n">IrqId_Gpio2</span><span class="p">,</span>
        <span class="n">IrqId_Gpio3</span><span class="p">,</span>
        <span class="n">IrqId_Gpio4</span><span class="p">,</span>
        <span class="n">IrqId_I2C</span><span class="p">,</span>
        <span class="n">IrqId_SPI</span><span class="p">,</span>
        <span class="n">IrqId_NumOfIds</span> <span class="c1">// Must be last</span>
    <span class="p">};</span>

    <span class="n">InterruptMgr</span><span class="p">();</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">registerHandler</span><span class="p">(</span><span class="n">IrqId</span> <span class="n">id</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="p">);</span>

    <span class="kt">void</span> <span class="n">enableInterrupt</span><span class="p">(</span><span class="n">IrqId</span> <span class="n">id</span><span class="p">);</span>

    <span class="kt">void</span> <span class="n">disableInterrupt</span><span class="p">(</span><span class="n">IrqId</span> <span class="n">id</span><span class="p">);</span>

    <span class="kt">void</span> <span class="n">handleInterrupt</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">EntryType</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">IrqInfo</span> <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Contains interrupt related information</span>
            <span class="c1">// per single IrqId</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">IrqInfo</span><span class="p">,</span> <span class="n">IrqId_NumOfIds</span><span class="o">&gt;</span> <span class="n">IrqsArray</span><span class="p">;</span>

    <span class="n">IrqsArray</span> <span class="n">irqs_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Every <strong>Driver</strong> will use <code>registerHandler()</code> member function to register its member function
as the handler for its <code>IrqId</code>. The <code>enableInterrupt()</code> and <code>disableInterrupt()</code> are also used by
the <strong>Device</strong> objects to control their interrupts on global level.</p>
</div>
<div class="paragraph">
<p>In order to use the <strong>Interrupt Manager</strong> described above every application has to implement proper
interrupt handler that will retrieve the reference to <code>device::InterruptMgr</code> object (via global/static
variables) and invoke its <code>handleInterrupt()</code> function, which in turn check the appropriate status
register(s) and invoke registered handler(s). Please note, that the handler will be executed in
interrupt context.</p>
</div>
<div class="paragraph">
<p>The code will look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">extern</span> <span class="s">"C"</span>
<span class="kt">void</span> <span class="nf">interruptHandler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">interruptMgr</span><span class="p">().</span><span class="n">handleInterrupt</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There may also be a need to enable/disable all the interrupts by toggling <code>i</code> flag in <code>CPS</code>
register. The same
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h">src/device/InterruptMgr.h</a> file
provides two function for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">device</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">interrupt</span>
<span class="p">{</span>

<span class="kr">inline</span>
<span class="kt">void</span> <span class="n">enable</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"cpsie i"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span>
<span class="kt">void</span> <span class="n">disable</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kr">__asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"cpsid i"</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace interrupt</span>

<span class="p">}</span>  <span class="c1">// namespace device</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_timer">Timer</h3>
<div class="paragraph">
<p>It is customary in bare metal development to flash leds in the first application
(instead of writing "Hello world"). However most tutorials show how to do it synchronously
using loops to wait some time before changing state of the led. I&#8217;m going to describe how to do
it asynchronously using timer interrupt in conjunction with <a href="#basic_concepts-event_loop">Event Loop</a>.</p>
</div>
<div class="paragraph">
<p>Almost every embedded platform has usually one or two timer peripherals. One such peripheral
can be programmed to provide an interrupt after some period of time. However, there may be a
need to have multiple timers that can be activated independently at the same time. It is quite
clear that there should be an entity that receives all the wait requests from various
<strong>Component</strong>s in non-interrupt context, then queues the wait requests internally,  programs
the timer peripheral to provide an interrupt after some time, and finally reports the completion to
appropriate <strong>Component</strong> via callback also in non-interrupt (event loop) context.</p>
</div>
<div class="paragraph">
<p>Such entity can be a generic (platform independent) <strong>Driver</strong>, if it is provided with platform specific
<strong>Device</strong> object, that exposes some predefined public interface and controls the actual platform specific hardware.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_mgr.png" alt="Image: Timer Manager">
</div>
</div>
<div class="paragraph">
<p>The asynchronous timer event handling follows the same pattern described in
<a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter.</p>
</div>
<div class="sect3">
<h4 id="_assigning_wait_complete_callback">Assigning Wait Complete Callback</h4>
<div class="paragraph">
<p>Just like described in <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter the <strong>Driver</strong> needs
to provide the "Wait Complete" callback object to be called when timer interrupt occurs.
The assignment is usually performed during initialisation/construction stage of the <strong>Driver</strong>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_callback.png" alt="Image: Assigning callback">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_starting_asynchronous_wait">Starting Asynchronous Wait</h4>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_start1.png" alt="Image: Starting Asynchronous Wait">
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> must be able to support multiple wait requests from various <strong>Components</strong> and manage
the internal queue accordingly. In the chart above the timer peripheral activated on the first
<code>asyncWait()</code> request. When the second request is issued (assuming <code>timeout1 &lt; timeout2</code> and
existing wait mustn&#8217;t be stopped), the <strong>Driver</strong> must prevent the completion of the currently
scheduled timer countdown being reported in interrupt context while interfering with an update
to internal data structures. The interrupts are disabled by calling <code>suspendWait()</code> member function
of the <strong>Device</strong>. The call to the <code>suspendWait()</code> returns <code>true</code>, which means the interrupts are
successfully disabled and it is safe to update internal data structures. If the call to <code>suspendWait()</code>
returns <code>false</code>, it means that the interrupt has already occurred and there is no existing wait
in progress, i.e. the second <code>asyncWait()</code> actually becomes a first one in the new sequence.</p>
</div>
<div class="paragraph">
<p>There also may be a case when <code>timeout2 &lt; timeout1</code> which means the order of the timeout requests
must be re-evaluated, and new wait re-programmed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_start2.png" alt="Image: Starting Asynchronous Wait">
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> must be able to cancel the existing timer countdown, evaluate how much time has passed
since the first request, evaluate the new values to reprogram the timer <strong>Device</strong> countdown again.</p>
</div>
</div>
<div class="sect3">
<h4 id="_completing_asynchronous_wait">Completing Asynchronous Wait</h4>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_complete.png" alt="Image: Completing Asynchronous Wait">
</div>
</div>
<div class="paragraph">
<p>Due to the fact that <strong>Driver</strong> may receive multiple independent wait requests, it must reprogram the
next wait (if such exists) while running in interrupt mode. Please pay attention to <code>InterruptCtx()</code>
tag parameter passed to the <code>startWait()</code> member function of the <strong>Device</strong>. It indicates that the request
is executed in interrupt context, while the same request used <code>EventLoopCtx()</code> as the tag parameter
to specify that the call was performed in event loop (non-interrupt) context.</p>
</div>
</div>
<div class="sect3">
<h4 id="_canceling_asynchronous_wait">Canceling Asynchronous Wait</h4>
<div class="paragraph">
<p>If there is a request to cancel the currently executed wait, the <strong>Driver</strong> must receive the information
about the elapsed time and reprogram the next wait if such exists.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_cancel1.png" alt="Image: Canceling Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>If the cancellation request to some other wait, that hasn&#8217;t been forwarded to the <strong>Device</strong>, the <strong>Driver</strong>
just needs to update its internal data structures without canceling currently performed timer countdown.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_cancel2.png" alt="Image: Canceling Asynchronous Operation">
</div>
</div>
<div class="paragraph">
<p>The unsuccessful attempts to cancel wait is performed in exactly the same way as described in
<a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timer_wait_cancel3.png" alt="Image: Canceling Asynchronous Operation">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_identifying_wait_requests">Identifying Wait Requests</h4>
<div class="paragraph">
<p>There is obviously a need to have some kind of identification of the wait requests in order to be able to cancel
some specific request while keeping the rest in waiting queue. One approach would be to have some kind of
a handle which can be used during the cancellation request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyTimerDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="p">...</span> <span class="n">Handle</span><span class="p">;</span>

    <span class="n">Handle</span> <span class="n">asyncWait</span><span class="p">(...);</span>

    <span class="kt">void</span> <span class="n">cancelWait</span><span class="p">(</span><span class="n">Handle</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another one is to hide the handle in some wrapper class, which makes it a bit safer to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyTimerDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">typedef</span> <span class="p">...</span> <span class="n">Handle</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">Timer</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Timer</span><span class="p">(</span><span class="n">MyTimerDriver</span><span class="o">&amp;</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">Handle</span> <span class="n">handle</span><span class="p">)</span>
          <span class="o">:</span> <span class="n">mgr_</span><span class="p">(</span><span class="n">mgr</span><span class="p">),</span>
            <span class="n">handle_</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">Timer</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="p">...</span> <span class="c1">// Invalidate the allocated handle</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">asyncWait</span><span class="p">(...)</span>
        <span class="p">{</span>
            <span class="n">mgr_</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span><span class="n">handle_</span><span class="p">,</span> <span class="p">...)</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">cancelWait</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">mgr_</span><span class="p">.</span><span class="n">cancelWait</span><span class="p">(</span><span class="n">handle_</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="nl">private:</span>
	<span class="n">MyTimerDriver</span><span class="o">&amp;</span> <span class="n">mgr_</span><span class="p">;</span>
        <span class="n">Handle</span> <span class="n">handle_</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Timer</span> <span class="n">allocTimer</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">someHandle</span> <span class="o">=</span> <span class="p">...;</span>
        <span class="k">return</span> <span class="n">Timer</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">someHandle</span><span class="p">)</span>
    <span class="p">}</span>

<span class="nl">private:</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimerMgr</span><span class="o">::</span><span class="n">Timer</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">asyncWait</span><span class="p">(</span><span class="n">Handle</span> <span class="n">handle</span><span class="p">,</span> <span class="p">...);</span>

    <span class="kt">void</span> <span class="n">cancelWait</span><span class="p">(</span><span class="n">Handle</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> itself has only one public function <code>allocTimer()</code>. It is used to allocate the <code>Timer</code>
object. All the wait and/or cancel requests are issued to this timer object directly, which is declared
to be a <code>friend</code> of the <strong>Driver</strong> class, i.e. it is able to call private functions of the latter using the
handle it has. The destructor of the <code>Timer</code> makes sure that the handle is properly invalidated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">MyTimerDriver</span> <span class="nf">driver</span><span class="p">(...);</span>
<span class="k">auto</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">driver</span><span class="p">.</span><span class="n">allocTimer</span><span class="p">();</span>
<span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(...);</span>
<span class="p">...</span>
<span class="n">timer</span><span class="p">.</span><span class="n">cancelWait</span><span class="p">();</span>
<span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The second approach is a bit safer than the first one and it is used in the implementation of such
generic "Timer Management Driver" in <a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_the_wait_duration">Specifying the Wait Duration</h4>
<div class="paragraph">
<p>The timer <strong>Device</strong> is platform specific. Some platforms may support wait duration granularity of a
microsecond, others can achieve only a millisecond. It usually depends on the system clock speed. However,
when using generic <strong>Driver</strong> and/or <strong>Component</strong> there is a need to be able to write platform independent
code that performs wait of the specified duration regardless of the <strong>Device</strong> in use. The
<strong>S</strong>tandard <strong>T</strong>emplate <strong>L</strong>ibrary (<strong>STL</strong>) of C&#43;&#43;11 standard provides convenient
<a href="http://en.cppreference.com/w/cpp/chrono">Date and Time Utilities</a> that make such usage possible.</p>
</div>
<div class="paragraph">
<p>In case the <strong>Device</strong> declares a minimal wait duration unit using
<a href="http://en.cppreference.com/w/cpp/chrono/duration">std::chrono::duration</a> type, the <strong>Driver</strong> may use
<a href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast">std::chrono::duration_cast</a> to convert
the requested wait duration to supported duration units.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyTimerDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span>
                                                <span class="n">WaitTimeUnitDuration</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopCtx</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">startWait</span><span class="p">(</span><span class="n">WaitTimeUnitDuration</span><span class="o">::</span><span class="n">rep</span> <span class="n">count</span><span class="p">,</span> <span class="n">EventLoopCtx</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above the minimal supported duration unit (<code>WaitTimeUnitDuration</code>) is declared to be
1 millisecond. Please note that <code>startWait()</code> member function expects to receive number of wait units,
i.e. milliseconds as its first parameter.</p>
</div>
<div class="paragraph">
<p>Then the definition of the <code>asyncWait()</code> member function of the <strong>Driver</strong> may be defined like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyTimerDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">WaitTimeUnitDuration</span> <span class="n">WaitTimeUnitDuration</span>
    <span class="k">class</span> <span class="nc">Timer</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TRep</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TPeriod</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">asyncWait</span><span class="p">(</span>
            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">TRep</span><span class="p">,</span> <span class="n">TPeriod</span><span class="o">&gt;&amp;</span> <span class="n">waitTime</span><span class="p">,</span>
            <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">castedWaitDuration</span> <span class="o">=</span>
                <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">WaitTimeUnitDuration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">waitTime</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">waitUnits</span> <span class="o">=</span> <span class="n">castedWaitDuration</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
            <span class="p">...</span> <span class="c1">// Call the asyncWait() of the driver with waitUnits as</span>
                <span class="c1">// first parameter.</span>
        <span class="p">}</span>

    <span class="p">};</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above the call below will perform correct adjustment of the duration and will measure
the same timeout with any <strong>Device</strong> whether the latter expects milliseconds or microseconds in its
<code>startWait()</code> member function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">...);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case the developer tries to execute a wait of several microseconds when <strong>Driver</strong> supports only
milliseconds granularity, the compilation will fail.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">...);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_driver_implementation">Driver Implementation</h4>
<div class="paragraph">
<p>The timer management <strong>Driver</strong> is a generic layer. It must work on any platform with any timer
<strong>Device</strong> object that exposes the right interface.</p>
</div>
<div class="paragraph">
<p>Such <strong>Driver</strong> is already implemented in <a href="https://github.com/arobenko/embxx">embxx</a> library as
<code>embxx::driver::TimerMgr</code> and resides in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/driver/TimerMgr.h">embxx/driver/TimerMgr.h</a> while
platform specific (Raspberry Pi) peripheral control object is implemented in
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project as <code>device::Timer</code> and resides in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h">src/device/Timer.h</a>.</p>
</div>
<div class="paragraph">
<p>The <code>embxx::driver::TimerMgr</code> is defined like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TMaxTimers</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TTimeoutHandler</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TimerMgr</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TimerMgr</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">);</span>
      <span class="o">:</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
        <span class="n">el_</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">TimerInfo</span> <span class="p">{</span>
        <span class="n">TTimeoutHandler</span> <span class="n">handler_</span><span class="p">;</span> <span class="c1">//</span>
        <span class="p">...;</span>                      <span class="c1">// Some other internal data</span>
    <span class="p">}</span>

    <span class="c1">// Internal data structures to track all the scheduled</span>
    <span class="c1">// wait requests.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">TimerInfo</span><span class="p">,</span> <span class="n">TMaxTimers</span><span class="o">&gt;</span> <span class="n">infos_</span><span class="p">;</span>

    <span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device_</span><span class="p">;</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TDevice</code> template parameter is Platform specific control class for timer peripheral.</p>
</div>
<div class="paragraph">
<p>The <code>TEventLoop</code> template parameter is the class of the <a href="#basic_concepts-event_loop">Event Loop</a>.</p>
</div>
<div class="paragraph">
<p>The <code>TMaxTimers</code> template parameters specifies the maximal number of timer objects the <code>TimerMgr</code>
will be able to allocate. This parameter is required because <code>embxx::driver::TimerMgr</code> was designed
to be used in the systems without dynamic memory allocation. If dynamic memory allocation is allowed,
then it is quite easy to implement similar functionality without this limitation.</p>
</div>
<div class="paragraph">
<p>The <code>TTimeoutHandler</code> template parameter specifies type of the timeout callback object.
This object must have <code>void (const embxx::error::ErrorStatus&amp;)</code> signature and expose similar interface to
<a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> or
<code>embxx::util::StaticFunction</code>.</p>
</div>
<div class="paragraph">
<p>The <code>embxx::driver::TimerMgr</code> exposes the following public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TimerMgr</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Timer</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="c1">// Destructor, removes Timer record from internal</span>
        <span class="c1">// data structures of TimerMgr</span>
        <span class="o">~</span><span class="n">Timer</span><span class="p">()</span> <span class="p">{...}</span>

        <span class="c1">// Activates asyncrhonous wait</span>
        <span class="kt">void</span> <span class="n">asyncWait</span><span class="p">(...)</span> <span class="p">{...}</span>

        <span class="c1">// Cancels scheduled asynchronous wait</span>
        <span class="kt">void</span> <span class="n">cancel</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="p">};</span>

    <span class="c1">// Allocate timer object</span>
    <span class="n">Timer</span> <span class="n">allocTimer</span><span class="p">()</span> <span class="p">{...}</span>

<span class="nl">private:</span>
    <span class="c1">// Allows usage of non-exposed private functions of</span>
    <span class="c1">// TimerMgr</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimerMgr</span><span class="o">::</span><span class="n">Timer</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The reader may notice that <code>embxx::driver::TimerMgr</code> exposes only one public function: <code>Timer allocTimer();</code>.
This function returns simple <code>TimerMgr::Timer</code> object which can be used to schedule new wait as well as
cancel the previous wait request.
Also note that <code>TimerMgr::Timer</code> class is declared to be a <code>friend</code> of <code>TimerMgr</code>. This is required to
allow seamless delegation of the wait/cancel request from <code>TimerMgr::Timer</code> to <code>TimerMgr</code>
which is responsible for managing multiple simultaneous wait requests and delegating them one by one
to the the actual hardware control object.</p>
</div>
<div class="paragraph">
<p>Then the led flashing application (implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_led_flash">src/app/app_led_flash</a>) can be as
simple as the code below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span>
<span class="p">{</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">LedChangeStateTimeout</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTimer</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ledOff</span><span class="p">(</span>
    <span class="n">TTimer</span><span class="o">&amp;</span> <span class="n">timer</span><span class="p">,</span>
    <span class="n">System</span><span class="o">::</span><span class="n">Led</span><span class="o">&amp;</span> <span class="n">led</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTimer</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ledOn</span><span class="p">(</span>
    <span class="n">TTimer</span><span class="o">&amp;</span> <span class="n">timer</span><span class="p">,</span>
    <span class="n">System</span><span class="o">::</span><span class="n">Led</span><span class="o">&amp;</span> <span class="n">led</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">led</span><span class="p">.</span><span class="n">on</span><span class="p">();</span>

    <span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
        <span class="n">LedChangeStateTimeout</span><span class="p">,</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">led</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
            <span class="n">ledOff</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">led</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTimer</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ledOff</span><span class="p">(</span>
    <span class="n">TTimer</span><span class="o">&amp;</span> <span class="n">timer</span><span class="p">,</span>
    <span class="n">System</span><span class="o">::</span><span class="n">Led</span><span class="o">&amp;</span> <span class="n">led</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">led</span><span class="p">.</span><span class="n">off</span><span class="p">();</span>

    <span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">LedChangeStateTimeout</span><span class="p">),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">led</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
            <span class="n">ledOn</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">led</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Get reference to TimerMgr object</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">timerMgr</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">timerMgr</span><span class="p">();</span>

    <span class="c1">// Allocate timer</span>
    <span class="k">auto</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">timerMgr</span><span class="p">.</span><span class="n">allocTimer</span><span class="p">();</span>

    <span class="c1">// Start flashing with initial state to be OFF</span>
    <span class="n">device</span><span class="o">::</span><span class="n">interrupt</span><span class="o">::</span><span class="n">enable</span><span class="p">();</span>
    <span class="n">ledOff</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">led</span><span class="p">);</span>

    <span class="c1">// Run the event loop</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">eventLoop</span><span class="p">();</span>
    <span class="n">el</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

    <span class="n">GASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Mustn't exit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_platform_specific_timer_device">Platform Specific Timer Device</h4>
<div class="paragraph">
<p>As it was already mentioned earlier, the <code>embxx::driver::TimerMgr</code> is a generic <strong>Driver</strong> class that does most
of the work of managing and scheduling independent wait requests. It requires support from low level timer
<strong>Device</strong> object to program the actual hardware of the platform the code runs on. The
<code>embxx::driver::TimerMgr</code> is defined to receive the <strong>Device</strong> class as template parameter as well as reference
to the <strong>Device</strong> timer object in the constructor. The <strong>Driver</strong> doesn&#8217;t know the exact <strong>Device</strong> type, but
expects it to expose certain public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span> <span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TimerMgr</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TimerMgr</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The timer control <strong>Device</strong> class must expose the following public interface:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define <code>WaitTimeUnitDuration</code> type as variation of
<a href="https://en.cppreference.com/w/cpp/chrono/duration">std::chrono::duration</a> that specifies duration of single
wait unit supported by the <strong>Device</strong>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">WaitTimeUnitDuration</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to set the callback object to be invoked from timer interrupt:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">setWaitCompleteCallback</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Functions to start timer countdown in both event loop (non-interrupt) and interrupt contexts:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">startWait</span><span class="p">(</span>
    <span class="n">WaitTimeUnitDuration</span><span class="o">::</span><span class="n">rep</span> <span class="n">waitTime</span><span class="p">,</span> <span class="c1">// num of wait units</span>
    <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">startWait</span><span class="p">(</span>
    <span class="n">WaitTimeUnitDuration</span><span class="o">::</span><span class="n">rep</span> <span class="n">waitTime</span><span class="p">,</span> <span class="c1">// num of wait units</span>
    <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to cancel timer countdown in event loop (non-interrupt) context. The function must return
true in case the wait was actually canceled and false when there is no wait in progress.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">cancelWait</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to suspend countdown (disable interrupts while the actual wait countdown is not stopped)
in event loop (non-interrupt) context. The function must return true in case the wait was actually
suspended and false when there is no wait in progress. The call to this function will be followed
either by <code>resumeWait()</code> or by <code>cancelWait()</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">suspendWait</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to resume countdown in event loop (non-interrupt) context.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">resumeWait</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to retrieve elapsed time of the last executed wait. It will be called right after the <code>cancelWait()</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">WaitTimeUnitDuration</span><span class="o">::</span><span class="n">rep</span> <span class="n">getElapsed</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The definition and implementation of such timer device for Raspberry Pi platform can be found in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h">src/device/Timer.h</a> file of
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peripherals-uart">UART</h3>
<div class="paragraph">
<p>Our next stage will be to support debug logging via UART interface. In conventional C&#43;&#43;
logging is performed using either <a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a> function or
<a href="http://en.cppreference.com/w/cpp/io/basic_ostream">output streams</a> (such as
<a href="http://en.cppreference.com/w/cpp/io/cout">std::cout</a> or
<a href="http://en.cppreference.com/w/cpp/io/cerr">std::cerr</a>).</p>
</div>
<div class="paragraph">
<p>If <code>printf</code> is used the compilation may fail at the linking stage with following errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-sbrkr.o): In function `_sbrk_r':
sbrkr.c:(.text._sbrk_r+0x18): undefined reference to `_sbrk'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-writer.o): In function `_write_r':
writer.c:(.text._write_r+0x20): undefined reference to `_write'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-closer.o): In function `_close_r':
closer.c:(.text._close_r+0x18): undefined reference to `_close'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-fstatr.o): In function `_fstat_r':
fstatr.c:(.text._fstat_r+0x1c): undefined reference to `_fstat'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-isattyr.o): In function `_isatty_r':
isattyr.c:(.text._isatty_r+0x18): undefined reference to `_isatty'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-lseekr.o): In function `_lseek_r':
lseekr.c:(.text._lseek_r+0x20): undefined reference to `_lseek'
/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-readr.o): In function `_read_r':
readr.c:(.text._read_r+0x20): undefined reference to `_read'
collect2: error: ld returned 1 exit status</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once these functions are stubbed with empty bodies, the compilation will succeed, but the image size
will be quite big (around 45KB).</p>
</div>
<div class="paragraph">
<p>The <code>_sbrk</code> function is required to support dynamic memory allocation. The <code>printf</code> function probably
uses <code>malloc()</code> to allocate some temporary buffers. If we open the assembly listing file we will see
calls to <code>&lt;malloc&gt;</code> and <code>&lt;free&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>_write</code> function is used to write characters into the standard output consol, which doesn&#8217;t
exist in embedded product. The developer must use this function implementation to write all the provided
characters to UART serial interface. Many developers implement this function in a straightforward
synchronous way with busy loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// stdout</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(...</span> <span class="cm">/* poll the status bit */</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// just wait</span>
            <span class="n">TX_REG</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
            <span class="o">++</span><span class="n">ptr</span><span class="p">;</span>
            <span class="o">--</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the call to <code>printf</code> function will be blocking and won&#8217;t return until all the characters
are written one by one to UART, which takes a lot of execution time. This approach is suitable for
quick and dirty debugging, but will quickly become impractical when the project grows.</p>
</div>
<div class="paragraph">
<p>In order to make the execution of <code>printf</code> quick, there must be some kind of interrupt driven component that
is responsible to buffer all the provided characters and forward it to UART asynchronously one by one using
"<strong>TX buffer register is free</strong>" kind of interrupts.</p>
</div>
<div class="paragraph">
<p>One of disadvantages in using <code>printf</code> for logging is a necessity to specify an output format of
the printed variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// some value</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Value = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case the type of the printed variable changes, the developer must remember to update type in the
format string too. This is the reason why many C&#43;&#43; developers prefer using streams instead
of <code>printf</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// some value</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value = "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if type of printed variable changes the compiler will generate a call to appropriate
overloaded <code>operator&lt;&lt;</code> of <a href="http://en.cppreference.com/w/cpp/io/basic_ostream">std::ostream</a>
and the value will be printed correctly. The developer will also have to implement the missing
<code>_write</code> function to write provided characters somewhere (UART interface in our case).</p>
</div>
<div class="paragraph">
<p>However using C&#43;&#43; streams in bare metal development is often not an option. They
use exceptions to handle error cases as well as <a href="http://en.cppreference.com/w/cpp/locale/locale">locales</a>
for formatting. The compilation of simple output statement with streams above created image of more than 500KB using
<a href="https://launchpad.net/gcc-arm-embedded">GNU Tools for ARM Embedded Processors</a> compiler.</p>
</div>
<div class="paragraph">
<p>To summarise all the stated above, there may be a problem to use standard
<a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a> function or
<a href="http://en.cppreference.com/w/cpp/io/basic_ostream">output streams</a> for debug logging, especially in systems
with small memory and where dynamic memory allocations and exceptions mustn&#8217;t be used. Our ultimate goal
will be creation of standard output stream like interface for debug logging while using asynchronous event
handling with <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model and <a href="#basic_concepts-event_loop">Event Loop</a> where
most of the code is generic and only smal part of managing write of a single character to the UART
interface is platform specific.</p>
</div>
<div class="paragraph">
<p>Asyncrhonous read and write operations on the UART interface are very similar to the generic way of
programming and handling asynchronous events described earlier in <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter.</p>
</div>
<div class="sect3">
<h4 id="_writing_to_uart">Writing to UART</h4>
<div class="paragraph">
<p><strong>Stage1</strong> - Sending asynchronous buffer write request from the <strong>Component</strong> layer to <strong>Driver</strong> in
event loop (non-interrupt) context.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_write1.png" alt="Image: Asyncrhonous write request">
</div>
</div>
<div class="paragraph">
<p>The <strong>Component</strong> calls <code>asyncWrite()</code> member function of the <strong>Driver</strong> and provides pointer to the buffer,
size of the buffer and the callback object to invoke when the write is complete. The <code>asyncWrite()</code> function
needs to be able to receive any type of callable object, such as
<a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind</a> expression or
<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda function</a>. To achieve this the function must
be templated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">CharacterDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="p">...</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCallbackFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncWrite</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TCallbackFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>According to the convention mentioned <a href="#basic_concepts-device_driver_component">earlier</a>,
the callback must receive an error status of whether the operation is successful as its first parameter.
When performing asynchronous operation on the buffer, it can be required to know how many characters have
been read / written before the error occurred, in case the operation wasn&#8217;t successful. For this purpose
such callback object must receive number of bytes written as the second parameter, i.e. expose
the <code>void (const embxx::error::ErrorStatus&amp; err, std::size_t bytesTransferred)</code> signature.</p>
</div>
<div class="paragraph">
<p>When the <strong>Driver</strong> receives the asynchronous operation request, it forwards it to the <strong>Device</strong>,
letting the latter know how many bytes will be written during the whole process. Please note that <strong>Driver</strong> uses <code>embxx::device::context::EventLoop</code> tag parameter to specify that <code>startWrite()</code> member function of
<strong>Device</strong> is invoked in event loop (non-interrut) context. The job of the <strong>Device</strong> object is to enable
appropriate interrupts and return immediately. Once the interrupt occurs, the stage of writing the data begins.</p>
</div>
<div class="paragraph">
<p><strong>Stage2</strong> - Writing provided data.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_write2.png" alt="Image: Writing provided data">
</div>
</div>
<div class="paragraph">
<p>Once the interrupt of "TX available" occurs, the <strong>Device</strong> must let the <strong>Driver</strong> know. There must
obviously be some kind of callback involved, which <strong>Driver</strong> must provide during its
construction / initialisation stage. Let&#8217;s assume at this moment that such assignment was successfully
done, and <strong>Device</strong> is capable of successfully notifying the <strong>Driver</strong>, that there is an ability to write
character to TX FIFO of the peripheral.</p>
</div>
<div class="paragraph">
<p>When the <strong>Driver</strong> receives such notification, it attempts to write as many characters as possible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptContext</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">canWriteCallback</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Executed in interrupt context, must be quick</span>
    <span class="k">while</span><span class="p">(</span><span class="n">device_</span><span class="p">.</span><span class="n">canWrite</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">()))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">writeBufStart_</span> <span class="o">+</span> <span class="n">writeBufSize_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">currentWriteBufPtr_</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">device_</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">currentWriteBufPtr_</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">());</span>
        <span class="o">++</span><span class="n">currentWriteBufPtr_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is because when "TX available" interrupt occurs, there may be a place for multiple characters to
be sent, not just one. Doing checks and writes in a loop may save many CPU cycles.</p>
</div>
<div class="paragraph">
<p>Please note, that all these calls are performed in interrupt context. They are marked in red in
the picture above.</p>
</div>
<div class="paragraph">
<p>Once the Tx FIFO of the underlying <strong>Device</strong> is full or there are no more characters to write,
the callback returns. The whole cycle described above is repeated on every "TX available" interrupt until
the whole provided buffer is sent to the <strong>Device</strong> for writing.</p>
</div>
<div class="paragraph">
<p><strong>Stage3</strong> - Notifying caller about completion:</p>
</div>
<div class="paragraph">
<p>Once the whole buffer is sent to the <strong>Device</strong> for writing, the <strong>Driver</strong> is aware that there will be no
more writes performed. However it doesn&#8217;t report completion until the <strong>Device</strong> itself calls appropriate
callback indicating that the operation has been indeed completed. Shifting the responsibility of
identifying when the operation is complete to <strong>Device</strong> will be needed later when we will want to reuse the same
<strong>Driver</strong> for <a href="#peripherals-i2c">I2C</a> and <a href="#peripherals-spi">SPI</a> peripherals. It will be important to know when internal
Tx FIFO of the peripheral becomes empty after all the characters from previous operation have been written.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_write3.png" alt="Image: Notifying caller about completion">
</div>
</div>
<div class="paragraph">
<p>Once the <strong>Driver</strong> receives notification from the <strong>Device</strong> (still in interrupt context), that the write operation
is complete, it bundles the callback object, provided with initial <code>asyncWrite()</code> request, together with error
status and number of actual bytes transferred using
<a href="http://en.cppreference.com/w/cpp/utility/functional/bind">std::bind</a> expression and sends the callable object
to <a href="#basic_concepts-event_loop">Event Loop</a> for execution in event loop (non-interrupt) context.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reading_from_uart">Reading from UART</h4>
<div class="paragraph">
<p>The reading from UART is done in a very similar manner.</p>
</div>
<div class="paragraph">
<p><strong>Stage1</strong> - Sending asynchronous buffer read request from the <strong>Component</strong> layer to <strong>Driver</strong> in event loop
(non-interrupt) context.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_read1.png" alt="Image: Asynchronous read request">
</div>
</div>
<div class="paragraph">
<p>The <code>asyncRead()</code> member function of the <strong>Driver</strong> should allow callback to be callable object of any type
(but one that exposes predefined signature of course).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">CharacterDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="p">...</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCallbackFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncRead</span><span class="p">(</span>
        <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TCallbackFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Stage2</strong> - Reading data into the buffer.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_read2.png" alt="Image: Writing provided data">
</div>
</div>
<div class="paragraph">
<p>The callback&#8217;s implementation will be something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="kt">void</span> <span class="nf">canReadCallback</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">device_</span><span class="p">.</span><span class="n">canRead</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">()))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">readBufStart_</span> <span class="o">+</span> <span class="n">readBufSize_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">currentReadBufPtr_</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">device_</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">());</span>
            <span class="o">*</span><span class="n">currentReadBufPtr_</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
            <span class="o">++</span><span class="n">currentReadBufPtr_</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Stage3</strong> - Notifying caller about completion:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_read3.png" alt="Image: Notifying caller about completion">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling_asynchronous_operations">Cancelling Asynchronous Operations</h4>
<div class="paragraph">
<p>The cancellation flow is very similar to the one described in <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_cancel_read1.png" alt="Image: Cancel read">
</div>
</div>
<div class="paragraph">
<p>If the cancellation is successful, the callback must be invoked with error code indicating that the
operation was aborted (<code>embxx::error::ErrorCode::Aborted</code>).</p>
</div>
<div class="paragraph">
<p>One possible case of unsuccessful cancellation is when callback was posted for execution in event loop,
but hasn&#8217;t been executed yet when cancellation is attempted. In this case <strong>Driver</strong> is aware that there
is no pending asynchronous operation and can return <code>false</code> immediately.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_cancel_read2.png" alt="Image: Cancel read">
</div>
</div>
<div class="paragraph">
<p>Another possible case of unsuccessful cancellation is when completion interrupt occurs in the middle
of cancellation request:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_cancel_read3.png" alt="Image: Cancel read">
</div>
</div>
</div>
<div class="sect3">
<h4 id="peripherals-uart-reading_until">Reading "Until"</h4>
<div class="paragraph">
<p>There may be a case, when partial read needs to be performed, for example until specific character
is encountered. In this case the <strong>Driver</strong> is responsible to monitor incoming characters and cancel
the read into the buffer operation before its completion:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/character_driver_flow_read_until.png" alt="Image: Notifying caller about completion">
</div>
</div>
<div class="paragraph">
<p>Note, that previously <strong>Driver</strong> called <code>cancelRead()</code> member function of the <strong>Device</strong> in event
loop (non-interrupt) context, while in "read until" situation the cancellation happens in interrupt mode.
That requires <strong>Device</strong> to implement these functions for both modes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>asyncReadUntil()</code> member function of the <strong>Driver</strong> should be able to receive any stateless
predicate object that defines <code>bool operator()(CharType ch) const</code>. The predicate invocation should
return <code>true</code> when expected character is received and reading operation must be stopped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TPred</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncReadUntil</span><span class="p">(</span>
        <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
        <span class="n">TPred</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It allows using complex conditions in evaluating the character. For example, stopping when either
<code>'\r'</code> or <code>'\n'</code> is encountered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span> <span class="n">EmbxxErrorStatus</span><span class="p">;</span>

<span class="n">driver_</span><span class="p">.</span><span class="n">asyncReadUntil</span><span class="p">(</span>
    <span class="n">buf</span><span class="p">,</span>
    <span class="n">bufSize</span><span class="p">,</span>
    <span class="p">[](</span><span class="n">CharType</span> <span class="n">ch</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'\r'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">);</span>
        <span class="p">},</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">EmbxxErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytesTransferred</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">});</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_device_implementation">Device Implementation</h4>
<div class="paragraph">
<p>In this section I will try to describe in more details what <strong>Device</strong> class needs to provide for the
<strong>Driver</strong> to work correctly. First of all it needs to define the type of characters used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">CharType</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> layer will reuse the definition of the character in its internal functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">asyncRead</span><span class="p">(</span><span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a need for <strong>Device</strong> to be able to record callback objects from the <strong>Driver</strong> in order to notify
the latter about an ability to read/write next character and about operation completion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanReadHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">canReadHandler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanWriteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">canWriteHandler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setReadCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">readCompleteHandler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setWriteCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeCompleteHandler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="p">...</span> <span class="n">OpAvailableHandler</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="p">...</span> <span class="n">OpCompleteHandler</span><span class="p">;</span>

    <span class="n">OpAvailableHandler</span> <span class="n">canReadHandler_</span><span class="p">;</span>
    <span class="n">OpCompleteHandler</span> <span class="n">readCompleteHandler_</span><span class="p">;</span>

    <span class="n">OpAvailableHandler</span> <span class="n">canWriteHandler_</span><span class="p">;</span>
    <span class="n">OpCompleteHandler</span> <span class="n">writeCompleteHandler_</span><span class="p">;</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>OpAvailableHandler</code> and <code>OpCompleteHandler</code> type may be either hard coded to be <code>std::function&lt;void ()&gt;</code>
and <code>std::function&lt;void (const embxx::error::ErrorStatus&amp;)&gt;</code> respectively or passed as template parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCanReadHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TCanWriteHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadCompleteHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWriteCompleteHandler</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span> <span class="c1">// setters are as above</span>

<span class="nl">private:</span>

    <span class="n">TCanReadHandler</span> <span class="n">canReadHandler_</span><span class="p">;</span>
    <span class="n">TReadCompleteHandler</span> <span class="n">readCompleteHandler_</span><span class="p">;</span>

    <span class="n">TCanWriteHandler</span> <span class="n">canWriteHandler_</span><span class="p">;</span>
    <span class="n">TWriteCompleteHandler</span> <span class="n">writeCompleteHandler_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Choosing the "template parameters option" is useful when the same <strong>Device</strong> class is reused between
multiple applications for the same product line.</p>
</div>
<div class="paragraph">
<p>The next stage would be implementing all the required functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopContext</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptContext</span><span class="p">;</span>

    <span class="c1">// Start read operation - enables interrupts</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Cancel read in event loop context</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Cancel read in interrupt context - used only if</span>
    <span class="c1">// asyncReadUntil() function was used in Device</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Start write operation - enables interrupts</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Cancell write operation</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Check whether there is a character available to be read.</span>
    <span class="kt">bool</span> <span class="n">canRead</span><span class="p">(</span><span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Check whether there is space for one character to be written.</span>
    <span class="kt">bool</span> <span class="n">canWrite</span><span class="p">(</span><span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Read the available character from Rx FIFO of the peripheral</span>
    <span class="n">CharType</span> <span class="n">read</span><span class="p">(</span><span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Write one more character to Tx FIFO of the peripheral</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">CharType</span> <span class="n">value</span><span class="p">,</span> <span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that there may be extra configuration functions specific for the peripheral being controlled.
For example baud rate, parity, flow control for UART. Such configuration is almost always platform
and/or product specific and usually performed at application startup. It is irrelevant to the
<a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model introduced in this book.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">configBaud</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project has multiple applications that use
UART1 interface for logging. The peripheral control code is the same for all of them and is implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Uart1.h">src/device/Uart1.h</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_driver_implementation_2">Driver Implementation</h4>
<div class="paragraph">
<p><strong>Driver</strong> must be a generic piece of code, that can be reused with any <strong>Device</strong> control object (as
long as it exposed right public interface) and in any application, including ones without dynamic memory allocation.</p>
</div>
<div class="paragraph">
<p>First of all, we will need references to <strong>Device</strong> as well as <a href="#basic_concepts-event_loop">Event Loop</a> objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Reuse definition of character type from the Device</span>
    <span class="k">typedef</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="c1">// During the construction store references to Device</span>
    <span class="c1">// and Event Loop objects.</span>
    <span class="n">MyDriver</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
        <span class="n">el_</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Register appropriate callbacks with device</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setCanReadHandler</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">MyDriver</span><span class="o">::</span><span class="n">canReadInterruptHandler</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setReadCompleteHandler</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">MyDriver</span><span class="o">::</span><span class="n">readCompleteInterruptHandler</span><span class="p">,</span>
                <span class="k">this</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>

        <span class="n">device_</span><span class="p">.</span><span class="n">setCanWriteHandler</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">MyDriver</span><span class="o">::</span><span class="n">canWriteInterruptHandler</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setWriteCompleteHandler</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">MyDriver</span><span class="o">::</span><span class="n">writeCompleteInterruptHandler</span><span class="p">,</span>
                <span class="k">this</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>

    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>

    <span class="kt">void</span> <span class="n">canReadInterruptHandler</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="kt">void</span> <span class="n">readCompleteInterruptHandler</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="kt">void</span> <span class="n">canWriteInterruptHandler</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="kt">void</span> <span class="n">writeCompleteInterruptHandler</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device_</span><span class="p">;</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We will also need to store callbacks provided with any asynchronous operation. Note that the "read" and
"write" are independent operations and it should be possible to perform <code>asyncRead()</code> and <code>asyncWrite()</code>
calls at the same time.</p>
</div>
<div class="paragraph">
<p>The only way to make <strong>Driver</strong> generic is to move responsibility of specifying callback storage type up one
level, i.e. we must put them as template parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadCompleteCallback</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWriteCompleteCallback</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopContext</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncRead</span><span class="p">(</span>
        <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">readBufStart_</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">currentReadBufPtr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">readBufSize_</span> <span class="o">=</span> <span class="n">bufSize</span><span class="p">;</span>
        <span class="n">readCompleteCallback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">driver_</span><span class="p">.</span><span class="n">startRead</span><span class="p">(</span><span class="n">bufSize</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncWrite</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeBufStart_</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">currentWriteBufPtr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">writeBufSize_</span> <span class="o">=</span> <span class="n">bufSize</span><span class="p">;</span>
        <span class="n">writeCompleteCallback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">driver_</span><span class="p">.</span><span class="n">startWrite</span><span class="p">(</span><span class="n">bufSize</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="p">...</span>

    <span class="c1">// Read info</span>
    <span class="n">CharType</span><span class="o">*</span> <span class="n">readBufStart_</span><span class="p">;</span>
    <span class="n">CharType</span><span class="o">*</span> <span class="n">currentReadBufPtr_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">readBufSize_</span><span class="p">;</span>
    <span class="n">TReadCompleteCallback</span> <span class="n">readCompleteCallback_</span><span class="p">;</span>

    <span class="c1">// Write info</span>
    <span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">writeBufStart_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">currentWriteBufPtr_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">writeBufSize_</span><span class="p">;</span>
    <span class="n">TWriteCompleteCallback</span> <span class="n">writeCompleteCallback_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As it was mentioned earlier in <a href="#peripherals-uart-reading_until">Reading "Until"</a> section, there is quite often a
need to stop reading characters into the provided buffer when some condition evaluates to true. It
means there is also a need to provide storage for the character evaluation predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadCompleteCallback</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWriteCompleteCallback</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadUntilPred</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopContext</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TPred</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncReadUntil</span><span class="p">(</span>
        <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TPred</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">readBufStart_</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">currentReadBufPtr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
        <span class="n">readBufSize_</span> <span class="o">=</span> <span class="n">bufSize</span><span class="p">;</span>
        <span class="n">readCompleteCallback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">readUntilPred_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TPred</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
        <span class="n">driver_</span><span class="p">.</span><span class="n">startRead</span><span class="p">(</span><span class="n">bufSize</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="p">...</span>

    <span class="c1">// Read info</span>
    <span class="n">CharType</span><span class="o">*</span> <span class="n">readBufStart_</span><span class="p">;</span>
    <span class="n">CharType</span><span class="o">*</span> <span class="n">currentReadBufPtr_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">readBufSize_</span><span class="p">;</span>
    <span class="n">TReadCompleteCallback</span> <span class="n">readCompleteCallback_</span><span class="p">;</span>
    <span class="n">TReadUntilPred</span> <span class="n">readUntilPred_</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The example code above may work, but it contradicts to one of the basic principles of C&#43;&#43;:
"You should pay only for what you use". In case of using UART for logging, there is no input from the
peripheral and it is a waist to keep data members for "read" required to manage "read" operations.
Let&#8217;s try to improve the situation a little bit by using template specialisation as well as reduce
number of template parameters by using "Traits" aggregation struct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">MyOutputTraits</span>
<span class="p">{</span>
    <span class="c1">// The "read" handler storage type.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">ReadHandler</span><span class="p">;</span>

    <span class="c1">// The "write" handler storage type.</span>
    <span class="c1">// The valid handler must have the following signature:</span>
    <span class="c1">//  "void handler(const embxx::error::ErrorStatus&amp;, std::size_t);"</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span>
        <span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">WriteHandler</span><span class="p">;</span>

    <span class="c1">// The "read until" predicate storage type</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">ReadUntilPred</span><span class="p">;</span>

    <span class="c1">// Read queue size</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ReadQueueSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Write queue size</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">WriteQueueSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that allowed number of pending "read" requests is specified as 0 in the traits
struct above, i.e. the read operations are not allowed. The "read complete" and "read until predicate"
types are irrelevant and specified as <a href="http://en.cppreference.com/w/cpp/types/nullptr_t">std::nullptr_t</a>.
The instantiation of the <strong>Driver</strong> object must take it into account and not include any "read" related
functionality. In order to achieve this the <strong>Driver</strong> class needs to have two independent sub-functionalities
of "read" and "write". It may be achieved by inheriting from two base classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TTraits</span> <span class="o">=</span> <span class="n">MyOutputTraits</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyDriver</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">ReadSupportBase</span><span class="o">&lt;</span>
                <span class="n">TDevice</span><span class="p">,</span>
                <span class="n">TEventLoop</span><span class="p">,</span>
                <span class="k">typename</span> <span class="n">TTraits</span><span class="o">::</span><span class="n">ReadHandler</span><span class="p">,</span>
                <span class="k">typename</span> <span class="n">TTraits</span><span class="o">::</span><span class="n">ReadUntilPred</span><span class="p">,</span>
                <span class="n">TTraits</span><span class="o">::</span><span class="n">ReadQueueSize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">public</span> <span class="n">WriteSupportBase</span><span class="o">&lt;</span>
                <span class="n">TDevice</span><span class="p">,</span>
                <span class="n">TEventLoop</span><span class="p">,</span>
                <span class="k">typename</span> <span class="n">TTraits</span><span class="o">::</span><span class="n">WriteHandler</span><span class="p">,</span>
                <span class="n">TTraits</span><span class="o">::</span><span class="n">WriteQueueSize</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">ReadSupportBase</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">ReadBase</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">WriteSupportBase</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">WriteBase</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TPred</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncRead</span><span class="p">(</span>
        <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ReadBase</span><span class="o">::</span><span class="n">asyncRead</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TPred</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncWrite</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WriteBase</span><span class="o">::</span><span class="n">asyncWrite</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, the template specialisation based on queue size should do the job:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadUntilPred</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ReadQueueSize</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ReadSupportBase</span><span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadUntilPred</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ReadSupportBase</span><span class="o">&lt;</span><span class="n">TDevice</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="p">,</span> <span class="n">TReadHandler</span><span class="p">,</span> <span class="n">TReadUntilPred</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ReadSupportBase</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="p">...</span> <span class="c1">// Implements the "read" related API</span>
<span class="nl">private:</span>
    <span class="p">...</span> <span class="c1">// Read related data members</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadHandler</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadUntilPred</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ReadSupportBase</span><span class="o">&lt;</span><span class="n">TDevice</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="p">,</span> <span class="n">TReadHandler</span><span class="p">,</span> <span class="n">TReadUntilPred</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ReadSupportBase</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span> <span class="p">{}</span>
    <span class="c1">// No need for any "read" related API and data members</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWriteHandler</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">WriteQueueSize</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">WriteSupportBase</span><span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TReadHandler</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">WriteSupportBase</span><span class="o">&lt;</span><span class="n">TDevice</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="p">,</span> <span class="n">TWriteHandler</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">WriteSupportBase</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="p">...</span> <span class="c1">// Implements the "write" related API</span>
<span class="nl">private:</span>
    <span class="p">...</span> <span class="c1">// Write related data members</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWriteHandler</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">WriteSupportBase</span><span class="o">&lt;</span><span class="n">TDevice</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="p">,</span> <span class="n">TWriteHandler</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">WriteSupportBase</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span> <span class="p">{}</span>
    <span class="c1">// No need for any "write" related API and data members</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that it is possible to implement general case when read/write queue size is greater than 1.
It will require some kind of request queuing (using <a href="#basic_needs-queue">Static (Fixed Size) Queue</a> for example) and will
allow issuing multiple asynchronous read/write requests at the same time.</p>
</div>
<div class="paragraph">
<p>In order to support this extension, the <strong>Device</strong> class must implement some extra functionality too:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The new read/write request can be issued by the <strong>Driver</strong> in interrupt context, after previous
operation reported completion.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
</li>
<li>
<p>When new asynchronous read/write request is issued to the <strong>Driver</strong> it must be able to prevent interrupt context callbacks from being invoked to avoid races on the internal data structure:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">suspendRead</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">resumeRead</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="kt">bool</span> <span class="n">suspendWrite</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">resumeWrite</span><span class="p">(</span><span class="n">EventLoopContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please pay attention to the boolean return value of <code>suspend*()</code> functions. They are like <code>cancel*()</code> ones, there is an indication whether the invocation of the callbacks is suspended or there is no operation currently in progress.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Such generic <strong>Driver</strong> is already implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/driver/Character.h">embxx/driver/Character.h</a> file of
<a href="https://github.com/arobenko/embxx">embxx</a> library. The <strong>Driver</strong> is called "Character", because it reads/writes the provided buffer one character at a time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_character_echo_application">Character Echo Application</h4>
<div class="paragraph">
<p>Now, it is time to do something practical. The
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_echo">app_uart1_echo</a> application
in <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project implements simple single character echo.</p>
</div>
<div class="paragraph">
<p>The <code>System</code> class in <a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_echo/System.h">System.h</a>
file defines the <strong>Device</strong> and <strong>Driver</strong> layers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">System</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">EventLoopSpaceSize</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">EventLoop</span><span class="o">&lt;</span>
        <span class="n">EventLoopSpaceSize</span><span class="p">,</span>
        <span class="n">device</span><span class="o">::</span><span class="n">InterruptLock</span><span class="p">,</span>
        <span class="n">device</span><span class="o">::</span><span class="n">WaitCond</span><span class="o">&gt;</span> <span class="n">EventLoop</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">device</span><span class="o">::</span><span class="n">InterruptMgr</span><span class="o">&lt;&gt;</span> <span class="n">InterruptMgr</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">device</span><span class="o">::</span><span class="n">Uart1</span><span class="o">&lt;</span><span class="n">InterruptMgr</span><span class="o">&gt;</span> <span class="n">Uart</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">driver</span><span class="o">::</span><span class="n">Character</span><span class="o">&lt;</span><span class="n">Uart</span><span class="p">,</span> <span class="n">EventLoop</span><span class="o">&gt;</span> <span class="n">UartSocket</span><span class="p">;</span>

    <span class="p">...</span>

<span class="nl">private:</span>

    <span class="p">...</span>
    <span class="n">EventLoop</span> <span class="n">el_</span><span class="p">;</span>
    <span class="n">Uart</span> <span class="n">uart_</span><span class="p">;</span>
    <span class="n">UartSocket</span> <span class="n">uartSocket_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>UartSocket</code> uses default "TTraits" template parameter of <code>embxx::driver::Character</code>, which is defined to be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">DefaultCharacterTraits</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span>
        <span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ReadHandler</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span>
        <span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">WriteHandler</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">ReadUntilPred</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ReadQueueSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">WriteQueueSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It allows usage of both "read" and "write" operations at the same time. Having the definitions in place
it is quite easy to implement the "echo" functionality:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Forward declaration</span>
<span class="kt">void</span> <span class="nf">writeChar</span><span class="p">(</span><span class="n">System</span><span class="o">::</span><span class="n">UartSocket</span><span class="o">&amp;</span> <span class="n">uartSocket</span><span class="p">,</span> <span class="n">System</span><span class="o">::</span><span class="n">Uart</span><span class="o">::</span><span class="n">CharType</span><span class="o">&amp;</span> <span class="n">ch</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">readChar</span><span class="p">(</span><span class="n">System</span><span class="o">::</span><span class="n">UartSocket</span><span class="o">&amp;</span> <span class="n">uartSocket</span><span class="p">,</span> <span class="n">System</span><span class="o">::</span><span class="n">Uart</span><span class="o">::</span><span class="n">CharType</span><span class="o">&amp;</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uartSocket</span><span class="p">.</span><span class="n">asyncRead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">uartSocket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytesRead</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="n">bytesRead</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytesRead</span><span class="p">);</span>
            <span class="n">writeChar</span><span class="p">(</span><span class="n">uartSocket</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeChar</span><span class="p">(</span><span class="n">System</span><span class="o">::</span><span class="n">UartSocket</span><span class="o">&amp;</span> <span class="n">uartSocket</span><span class="p">,</span> <span class="n">System</span><span class="o">::</span><span class="n">Uart</span><span class="o">::</span><span class="n">CharType</span><span class="o">&amp;</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uartSocket</span><span class="p">.</span><span class="n">asyncWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">uartSocket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytesWritten</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="n">bytesWritten</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytesWritten</span><span class="p">);</span>
            <span class="n">readChar</span><span class="p">(</span><span class="n">uartSocket</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">uart</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">uart</span><span class="p">();</span>

    <span class="c1">// Configure serial interface</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">configBaud</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">setReadEnabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">setWriteEnabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Start with asynchronous read</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">uartSocket</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">uartSocket</span><span class="p">();</span>
    <span class="n">System</span><span class="o">::</span><span class="n">Uart</span><span class="o">::</span><span class="n">CharType</span> <span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">readChar</span><span class="p">(</span><span class="n">uartSocket</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>

    <span class="c1">// Run the event loop</span>
    <span class="n">device</span><span class="o">::</span><span class="n">interrupt</span><span class="o">::</span><span class="n">enable</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">eventLoop</span><span class="p">();</span>
    <span class="n">el</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

    <span class="n">GASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Mustn't exit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stream_like_printing_interface">Stream-like Printing Interface</h4>
<div class="paragraph">
<p>As was mentioned earlier, our ultimate goal would be having standard output stream like interface
for debug output, which works asynchronously without any blocking busy waits. Such interface must
be a generic <strong>Component</strong>, which works in non-interrupt context, while using recently covered generic
"Character" <strong>Driver</strong> in conjunction with platform specific "Uart" <strong>Device</strong>.</p>
</div>
<div class="paragraph">
<p>Such <strong>Component</strong> should be implemented as two sub-<strong>Components</strong>. One is "Stream Buffer" which is
responsible to maintain circular buffer of written characters and flush them to the peripheral
using "Character" <strong>Driver</strong> when needed. The characters, that have been successfully written,
are removed from the internal buffer. The second one is "Stream" itself, which is responsible
to convert various values into characters and write them to the end of the "Stream Buffer".</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stream.png" alt="Image: Stream">
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start with "Output Stream Buffer" first. It needs to receive reference to the <strong>Driver</strong> it&#8217;s going to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">OutStreamBuf</span><span class="p">(</span><span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">driver_</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="nl">private:</span>
   <span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver_</span><span class="p">;</span>
   <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a need to have a buffer, where characters are stored before they are written to the
device. Remember that we are trying to create a <strong>Component</strong>, which can be reused in multiple
independent projects, including ones that do not support dynamic memory allocation. Hence,
<a href="#basic_needs-queue">Static (Fixed Size) Queue</a> may be a good choice for it. It means, there is a need to provide size of the
buffer as one of the template arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDriver</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">CharType</span><span class="p">,</span> <span class="n">BufSize</span><span class="o">&gt;</span> <span class="n">Buffer</span><span class="p">;</span>

<span class="nl">private:</span>
   <span class="p">...</span>
   <span class="n">Buffer</span> <span class="n">buf_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The "Output Stream Buffer" needs to support two main operations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Pushing new single character at the end of the buffer.</p>
</li>
<li>
<p>Flushing all (or part of) written characters, i.e. activate asynchronous write with <strong>Driver</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When pushing a new character, there may be a case when the internal buffer is full. In this case,
the pushed character needs to be discarded and there must be an indication whether "push" operation
was successful. The function may return either <code>bool</code> to indicate success of the operation or
<code>std::size_t</code> to inform the caller how may characters where written. If <code>0</code> is returned, the
character wasn&#8217;t written.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="c1">// Add new character at the end of the buffer</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">pushBack</span><span class="p">(</span><span class="n">CharType</span> <span class="n">ch</span><span class="p">);</span>

   <span class="c1">// Get number of written, not-flushed characters</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">();</span>

   <span class="c1">// Flush number of characters</span>
   <span class="kt">void</span> <span class="n">flush</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span><span class="p">());</span>
   <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This limited number of operations is enough to implement "Output Stream" - like interface.
However, "Output Stream Buffer" can be useful in writing any serialised data into the peripheral,
not only the debug output. For example using standard algorithms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStreamBuf</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">outStreamBuf</span><span class="p">(...);</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="mi">128</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{{...</span><span class="cm">/* some data*/</span><span class="p">}};</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">outStreamBuf</span><span class="p">));</span>
<span class="n">outStreamBuf</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <a href="http://en.cppreference.com/w/cpp/iterator/back_inserter">std::back_inserter</a> requires
a container to define <code>push_back()</code> member function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
   <span class="c1">// Wrap pushBack()</span>
   <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">CharType</span> <span class="n">ch</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="n">pushBack</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There also may be a need to iterate over written, but still not flushed, characters and update some of
them before the call to <code>flush()</code>. In other words the "Output Stream Buffer" must be treated as random
access container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">CharType</span><span class="p">,</span> <span class="n">BufSize</span><span class="o">&gt;</span> <span class="n">Buffer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">Iterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ConstIterator</span> <span class="n">ConstIterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ValueType</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">Reference</span> <span class="n">Reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ConstReference</span> <span class="n">ConstReference</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">newSize</span><span class="p">);</span>

    <span class="n">Iterator</span> <span class="n">begin</span><span class="p">();</span>
    <span class="n">Iterator</span> <span class="n">end</span><span class="p">();</span>

    <span class="n">ConstIterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstIterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">ConstIterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstIterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">ConstReference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As was mentioned earlier, the <code>OutStreamBuf</code> uses <a href="#basic_needs-queue">Static (Fixed Size) Queue</a> as its internal buffer and any
characters pushed beyond the capacity gets discarded. There must be a way to identify available capacity
as well as request asynchronous notification via callback when requested capacity becomes available:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TWaitHandler</span> <span class="o">=</span>
              <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">availableCapacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncWaitAvailableCapacity</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span>
        <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="n">availableCapacity</span><span class="p">())</span> <span class="p">{</span>
            <span class="p">...</span> <span class="c1">// invoke callback via post() member function of Event Loop</span>
        <span class="p">}</span>
        <span class="n">waitAvailableCapacity_</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">waitHandler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>

        <span class="c1">// The Driver is writing some portion of flushed characters,</span>
        <span class="c1">// evaluate the capacity again when Driver reports completion.</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">waitAvailableCapacity_</span><span class="p">;</span>
    <span class="n">WaitHandler</span> <span class="n">waitHandler_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such "Output Stream Buffer" is already implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/io/OutStreamBuf.h">embxx/io/OutStreamBuf.h</a> file of
<a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
<div class="paragraph">
<p>The next stage would be defining the "Output Stream" class, which will allow printing of null terminated
strings as well as various integral values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TStreamBuf</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TStreamBuf</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="n">OutStream</span><span class="p">(</span><span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">buf_</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="p">(</span><span class="n">OutStream</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="o">~</span><span class="n">OutStream</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">flush</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">buf_</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">CharType</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buf_</span><span class="p">.</span><span class="n">pushBack</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
            <span class="o">++</span><span class="n">str</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">buf_</span><span class="p">.</span><span class="n">pushBack</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Cast std::uint8_t to unsigned and print.</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Cast std::int16_t to int type and print.</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Cast std::uint16_t to unsigned and print</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Print signed value</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Print unsigned value</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Print 64 bit signed value</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// Print 64 bit signed value</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We will also require the numeric base representation and manipulator. Unfortunately, usage of
<code>std::oct</code>, <code>std::dec`or `std::hex</code> manipulators will require inclusion of standard library
header <a href="http://en.cppreference.com/w/cpp/header/ios">&lt;ios&gt;</a>, which in turn includes other standard
stream related headers, which define some static objects, which in turn are defined and instantiated
in standard library. It contradicts our main goal of writing generic code that doesn&#8217;t require
standard library to be used. It is better to define such manipulators ourselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="n">bin</span><span class="p">,</span> <span class="c1">///&lt; Binary numeric base stream manipulator</span>
    <span class="n">oct</span><span class="p">,</span> <span class="c1">///&lt; Octal numeric base stream manipulator</span>
    <span class="n">dec</span><span class="p">,</span> <span class="c1">///&lt; Decimal numeric base stream manipulator</span>
    <span class="n">hex</span><span class="p">,</span> <span class="c1">///&lt; Hexadecimal numeric base stream manipulator</span>
    <span class="n">Base_NumOfBases</span> <span class="c1">///&lt; Must be last</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TStreamBuf</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">OutStream</span><span class="p">(</span><span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">buf_</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
      <span class="n">base_</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Base</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">base_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf_</span><span class="p">;</span>
    <span class="n">Base</span> <span class="n">base_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the numeric base representation must be taken into account when creating string
representation of numeric values. The usage is very similar to standard:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStream</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">stream</span><span class="p">;</span>

<span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">"var1="</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">var1</span> <span class="o">&lt;&lt;</span> <span class="s">"; var2="</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">var2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="n">stream</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It may be convenient to support a little bit of formatting, such as specifying minimal width of
the output as well as fill character:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">WidthManip</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ValueManipBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">WidthManip</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;}</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span>
<span class="n">WidthManip</span> <span class="nf">setw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">WidthManip</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FillManip</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FillManip</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;}</span>
<span class="nl">private:</span>
    <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span>
<span class="n">FillManip</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">setfill</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">FillManip</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TStreamBuf</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">OutStream</span><span class="p">(</span><span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">buf_</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
      <span class="n">base_</span><span class="p">(</span><span class="n">dec</span><span class="p">),</span>
      <span class="n">width_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
      <span class="n">fill_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">WidthManip</span> <span class="n">manip</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">width_</span> <span class="o">=</span> <span class="n">manip</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">details</span><span class="o">::</span><span class="n">FillManip</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">manip</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fill_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">manip</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TStreamBuf</span><span class="o">&amp;</span> <span class="n">buf_</span><span class="p">;</span>
    <span class="n">Base</span> <span class="n">base_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">width_</span><span class="p">;</span>
    <span class="n">CharType</span> <span class="n">fill_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The usage is very similar to the base manipulator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStream</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">stream</span><span class="p">;</span>

<span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">"var1="</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">var1</span> <span class="o">&lt;&lt;</span> <span class="s">"; var2="</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span>
       <span class="o">&lt;&lt;</span> <span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">var2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="n">stream</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another useful manipulator is adding '\n' at the end as well as calling <code>flush()</code>, just like
<code>std::endl</code> does when using standard output streams:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">Endl</span>
<span class="p">{</span>
    <span class="n">endl</span> <span class="c1">///&lt; End of line stream manipulator</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TStreamBuf</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">OutStream</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="n">OutStream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">Endl</span> <span class="n">manip</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">manip</span><span class="p">);</span>
        <span class="n">buf_</span><span class="p">.</span><span class="n">pushBack</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="n">flush</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>


<span class="nl">private:</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then usage example may be changed to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStream</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">stream</span><span class="p">;</span>

<span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">"var1="</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">var1</span> <span class="o">&lt;&lt;</span> <span class="s">"; var2="</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span>
       <span class="o">&lt;&lt;</span> <span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">var2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>To summarise</strong>: The "Output Stream" object converts given integer value into the printable
characters and uses <code>pushBack()</code> member function of "Output Stream Buffer" to pass these characters
further. The request to <code>flush()</code> is also passed on. When "Output Stream Buffer" receives a request
to flush internal buffer it activates the "Character" <strong>Driver</strong>, which it turn uses "UART" <strong>Device</strong>
to write characters to serial interface one by one. As the result of such cooperation, the "printing"
statement is very quick, there is no wait for all the characters to be written before the function
returns, like it is usually done with <code>printf()</code>. All the characters are written at the background
using interrupts, while the main thread of the application continues its execution without stalling.</p>
</div>
<div class="paragraph">
<p>Such "Output Stream" is already implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/io/OutStream.h">embxx/io/OutStream.h</a> file of
<a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logging">Logging</h4>
<div class="paragraph">
<p>In general, debug logging should be under conditional compilation, for example only in <strong>DEBUG</strong> mode,
while the printing code is excluded when compiling in <strong>RELEASE</strong> mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#ifndef NDEBUG
</span>    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">"Some info massage"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="cp">#endif</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes there is a need to easily change the amount of debug messages being printed. For
that purpose, the concept of logging levels is widely used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">log</span>
<span class="p">{</span>

<span class="k">enum</span> <span class="n">Level</span>
<span class="p">{</span>
    <span class="n">Trace</span><span class="p">,</span> <span class="c1">///&lt; Use for tracing enter to and exit from functions.</span>
    <span class="n">Debug</span><span class="p">,</span> <span class="c1">///&lt; Use for debugging information.</span>
    <span class="n">Info</span><span class="p">,</span> <span class="c1">///&lt; Use for general informative output.</span>
    <span class="n">Warning</span><span class="p">,</span> <span class="c1">///&lt; Use for warning about potential dangers.</span>
    <span class="n">Error</span><span class="p">,</span> <span class="c1">///&lt; Use to report execution errors.</span>
    <span class="n">NumOfLogLevels</span> <span class="c1">///&lt; Number of log levels, must be last</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace log</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The logging statement becomes a macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">const</span> <span class="k">auto</span> <span class="n">MinLogLevel</span> <span class="o">=</span> <span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">;</span>

<span class="cp">#define LOG(stream__, level__, output__) \
    do { \
        if (MinLevel &lt;= (level__)) { \
            (stream__).stream() &lt;&lt; output__; \
        } \
    } while (false)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case all the logging attempts for level below <code>log::Info</code> get optimised away by the compiler,
because the <code>if</code> statement known to evaluate to <code>false</code> at compile time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span> <span class="s">"This message is not printed."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">);</span>
<span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">,</span> <span class="s">"This message IS printed."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">);</span>
<span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Warning</span><span class="p">,</span> <span class="s">"This message IS printed also."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It would be nice to be able to add some automatic formatting to the logged statements, such as
printing the log level and/or adding '\n' and flushing at the end. For example, the code below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span> <span class="s">"This is DEBUG message."</span><span class="p">);</span>
<span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">,</span> <span class="s">"This is INFO message."</span><span class="p">);</span>
<span class="n">LOG</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Warning</span><span class="p">,</span> <span class="s">"This is WARNING message."</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>to produce the following output</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[DEBUG]: This is DEBUG message.
[INFO]: This is INFO message.
[WARNING]: This is WARNING message.</pre>
</div>
</div>
<div class="paragraph">
<p>with <code>'\n'</code> character and call to <code>flush()</code> at the end.</p>
</div>
<div class="paragraph">
<p>It is easy to achieve when using some kind of wrapper logging class around the output stream as well as relevant formatters.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">TLevel</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TStream</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StreamLogger</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">typedef</span> <span class="n">TStream</span> <span class="n">Stream</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">MinLevel</span> <span class="o">=</span> <span class="n">TLevel</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="n">StreamLogger</span><span class="p">(</span><span class="n">Stream</span><span class="o">&amp;</span> <span class="n">outStream</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">outStream_</span><span class="p">(</span><span class="n">outStream</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">outStream_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Begin output. This function is called before requested</span>
    <span class="c1">// output is redirected to stream. It does nothing.</span>
    <span class="kt">void</span> <span class="n">begin</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// End output. This function is called after requested</span>
    <span class="c1">// output is redirected to stream. It does nothing.</span>
    <span class="kt">void</span> <span class="n">end</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">outStream_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The logging macro will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define SLOG(log__, level__, output__) \
    do { \
        if ((log__).MinLevel &lt;= (level__)) { \
            (log__).begin(level__); \
            (log__).stream() &lt;&lt; output__; \
            (log__).end(level__); \
        } \
    } while (false)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A formatter can be defined by exposing the same interface, but wraps the original <code>StreamLogger</code> or
another formatter. For example let&#8217;s define formatter that calls <code>flush()</code> member function of the
stream when output is complete:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TNextLayer</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StreamFlushSuffixer</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="c1">// Constructor, forwards all the other parameters to the constructor</span>
    <span class="c1">// of the next layer.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TParams</span><span class="o">&gt;</span>
    <span class="n">StreamFlushSuffixer</span><span class="p">(</span><span class="n">TParams</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">nextLavel_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TParams</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">nextLavel_</span><span class="p">.</span><span class="n">stream</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">begin</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">end</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
        <span class="n">stream</span><span class="p">().</span><span class="n">flush</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNextLavel</span> <span class="n">nextLavel_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of such logger would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="p">...</span> <span class="n">OutStream</span><span class="p">;</span> <span class="c1">// type of the output stream</span>
<span class="k">typedef</span>
    <span class="n">StreamFlushSuffixer</span><span class="o">&lt;</span>
        <span class="n">StreamLogger</span><span class="o">&lt;</span>
            <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span>
            <span class="n">OutStream</span>
        <span class="o">&gt;</span>
    <span class="o">&gt;</span> <span class="n">Log</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The same <code>SLOG()</code> macro will work for this logger with extra formatting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStream</span> <span class="nf">stream</span><span class="p">(...</span> <span class="cm">/* construction params */</span><span class="p">);</span>
<span class="n">Log</span> <span class="nf">log</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="n">SLOG</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span> <span class="s">"This is DEBUG message.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s also add a formatter that capable of printing any value (and <code>'\n'</code> in particular) at the end of the output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNextLayer</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StreamableValueSuffixer</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TParams</span><span class="o">&gt;</span>
    <span class="k">explicit</span> <span class="n">StreamableValueSuffixer</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">TParams</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span>
        <span class="n">nextLevel_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TParams</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">nextLavel_</span><span class="p">.</span><span class="n">stream</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">begin</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">end</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
        <span class="n">stream</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>


<span class="nl">private:</span>
    <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
    <span class="n">TNextLavel</span> <span class="n">nextLavel_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of the logger that adds <code>'\n'</code> character and then calls <code>flush()</code> member function of
the underlying stream would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">OutStream</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">OutStream</span><span class="p">;</span>
<span class="k">typedef</span>
    <span class="n">StreamFlushSuffixer</span><span class="o">&lt;</span>
        <span class="n">StreamableValueSuffixer</span><span class="o">&lt;</span>
            <span class="kt">char</span><span class="p">,</span>
            <span class="n">StreamLogger</span><span class="o">&lt;</span>
                <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span>
                <span class="n">OutStream</span>
            <span class="o">&gt;</span>
        <span class="o">&gt;</span>
    <span class="o">&gt;</span> <span class="n">Log</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>While the construction will require to specify the character which is going to be printed at the end,
but before call to <code>flush()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OutStream</span> <span class="nf">stream</span><span class="p">(...);</span>
<span class="n">Log</span> <span class="nf">log</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
<span class="n">SLOG</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span> <span class="s">"This is DEBUG message."</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the last formatter, let&#8217;s do the one that prefixes the output with log level information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TNextLayer</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LevelStringPrefixer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TParams</span><span class="o">&gt;</span>
    <span class="n">LevelStringPrefixer</span><span class="p">(</span><span class="n">TParams</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">);</span>
      <span class="o">:</span> <span class="n">next_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TParams</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">nextLavel_</span><span class="p">.</span><span class="n">stream</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">begin</span><span class="p">(</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">Strings</span><span class="p">[</span><span class="n">NumOfLogLevels</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"[TRACE] "</span><span class="p">,</span>
            <span class="s">"[DEBUG] "</span><span class="p">,</span>
            <span class="s">"[INFO] "</span><span class="p">,</span>
            <span class="s">"[WARNING] "</span><span class="p">,</span>
            <span class="s">"[ERROR] "</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">NumOfLogLevels</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Strings</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">stream</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Strings</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">end</span><span class="p">(</span><span class="n">log</span><span class="o">::</span><span class="n">Level</span> <span class="n">level</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nextLavel_</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNextLavel</span> <span class="n">nextLavel_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of the logger that prints such a prefix at the beginning and <code>'\n'</code> at the end together
with call to <code>flush()</code> would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span>
    <span class="n">StreamFlushSuffixer</span><span class="o">&lt;</span>
        <span class="n">StreamableValueSuffixer</span><span class="o">&lt;</span>
            <span class="kt">char</span><span class="p">,</span>
            <span class="n">LevelStringPrefixer</span><span class="o">&lt;</span>
                <span class="n">StreamLogger</span><span class="o">&lt;</span>
                    <span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span>
                    <span class="n">OutStream</span>
                <span class="o">&gt;</span>
            <span class="o">&gt;</span>
        <span class="o">&gt;</span>
    <span class="o">&gt;</span> <span class="n">Log</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such <code>StreamLogger</code> together with multiple formatters is already implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/util/StreamLogger.h">embxx/util/StreamLogger.h</a> file of
<a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logging_application">Logging Application</h4>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_logging">app_uart1_logging</a>
application in <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project implements logging of
simple counter that gets incremented once a second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">log</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TLog</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TTimer</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">performLog</span><span class="p">(</span><span class="n">TLog</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">,</span> <span class="n">TTimer</span><span class="o">&amp;</span> <span class="n">timer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">counter</span><span class="p">;</span>

    <span class="n">SLOG</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">,</span>
        <span class="s">"Logging output: counter = "</span> <span class="o">&lt;&lt;</span>
        <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span> <span class="o">&lt;&lt;</span>
        <span class="s">" (0x"</span> <span class="o">&lt;&lt;</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span><span class="p">);</span>

    <span class="c1">// Perform next logging after a timeout</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">LoggingWaitPeriod</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
        <span class="n">LoggingWaitPeriod</span><span class="p">,</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
            <span class="n">performLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="p">});</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">log</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>

    <span class="c1">// Configure UART</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">uart</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">uart</span><span class="p">();</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">configBaud</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">setWriteEnabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Timer allocation</span>
    <span class="k">auto</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">timerMgr</span><span class="p">().</span><span class="n">allocTimer</span><span class="p">();</span>
    <span class="n">GASSERT</span><span class="p">(</span><span class="n">timer</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>

    <span class="c1">// Start logging</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">performLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>

    <span class="c1">// Run event loop</span>
    <span class="n">device</span><span class="o">::</span><span class="n">interrupt</span><span class="o">::</span><span class="n">enable</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">eventLoop</span><span class="p">();</span>
    <span class="n">el</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

    <span class="n">GASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Mustn't exit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_logging/System.h">System.h</a>
file defines the whole output stack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">System</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">EventLoopSpaceSize</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">EventLoop</span><span class="o">&lt;</span>
        <span class="n">EventLoopSpaceSize</span><span class="p">,</span>
        <span class="n">device</span><span class="o">::</span><span class="n">InterruptLock</span><span class="p">,</span>
        <span class="n">device</span><span class="o">::</span><span class="n">WaitCond</span><span class="o">&gt;</span> <span class="n">EventLoop</span><span class="p">;</span>

    <span class="c1">// Devices</span>
    <span class="k">typedef</span> <span class="n">device</span><span class="o">::</span><span class="n">Uart1</span><span class="o">&lt;</span><span class="n">InterruptMgr</span><span class="o">&gt;</span> <span class="n">Uart</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="c1">// Drivers</span>
    <span class="k">struct</span> <span class="n">CharacterTraits</span>
    <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">ReadHandler</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span>
            <span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">WriteHandler</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">ReadUntilPred</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ReadQueueSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">WriteQueueSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">driver</span><span class="o">::</span><span class="n">Character</span><span class="o">&lt;</span>
        <span class="n">Uart</span><span class="p">,</span> <span class="n">EventLoop</span><span class="p">,</span> <span class="n">CharacterTraits</span><span class="o">&gt;</span> <span class="n">UartDriver</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="c1">// Components</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">OutStreamBufSize</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">OutStreamBuf</span><span class="o">&lt;</span>
        <span class="n">UartDriver</span><span class="p">,</span> <span class="n">OutStreamBufSize</span><span class="o">&gt;</span> <span class="n">OutStreamBuf</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">OutStream</span><span class="o">&lt;</span><span class="n">OutStreamBuf</span><span class="o">&gt;</span> <span class="n">OutStream</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">StreamFlushSuffixer</span><span class="o">&lt;</span>
            <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">StreamableValueSuffixer</span><span class="o">&lt;</span>
                <span class="k">const</span> <span class="n">OutStream</span><span class="o">::</span><span class="n">CharType</span><span class="o">*</span><span class="p">,</span>
                <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">LevelStringPrefixer</span><span class="o">&lt;</span>
                    <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StreamLogger</span><span class="o">&lt;</span>
                        <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">Debug</span><span class="p">,</span>
                        <span class="n">OutStream</span>
                    <span class="o">&gt;</span>
                <span class="o">&gt;</span>
            <span class="o">&gt;</span>
        <span class="o">&gt;</span> <span class="n">Log</span><span class="p">;</span>

    <span class="p">...</span>
<span class="nl">private:</span>

    <span class="n">EventLoop</span> <span class="n">el_</span><span class="p">;</span>

    <span class="c1">// Devices</span>
    <span class="n">Uart</span> <span class="n">uart_</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="c1">// Drivers</span>
    <span class="n">UartDriver</span> <span class="n">uartDriver_</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="c1">// Components</span>
    <span class="n">OutStreamBuf</span> <span class="n">buf_</span><span class="p">;</span>
    <span class="n">OutStream</span> <span class="n">stream_</span><span class="p">;</span>
    <span class="n">Log</span> <span class="n">log_</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This application will produce the following output to the UART interface with new line appearing every second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[INFO] Logging output: counter = 1 (0x1)
[INFO] Logging output: counter = 2 (0x2)
[INFO] Logging output: counter = 3 (0x3)
...</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buffered_input">Buffered Input</h4>
<div class="paragraph">
<p>In many systems the UART interfaces are also used to communicate between various microcontrollers on the same
board or with external devices. When there are incoming messages, the characters must be stored in some
buffer before they can be processed by some <strong>Component</strong>. Just like we had "Output Stream Buffer" for
buffering outgoing characters, we must have "Input Stream Buffer" for buffering incoming ones.</p>
</div>
<div class="paragraph">
<p>It must obviously have an access to the Character <strong>Driver</strong> and will probably have a circular buffer
to store incoming characters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDriver</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="n">CharType</span><span class="p">,</span> <span class="n">TBufSize</span><span class="o">&gt;</span> <span class="n">Buffer</span><span class="p">;</span>

    <span class="k">explicit</span>
    <span class="n">InStreamBuf</span><span class="p">(</span><span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">driver_</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TDriver</span><span class="o">&amp;</span> <span class="n">driver_</span><span class="p">;</span>
    <span class="n">Buffer</span> <span class="n">buf_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> won&#8217;t perform any read operations unless it is explicitly requested to do so with its
<code>asyncRead()</code> member function. Sometimes, there is a need to keep characters flowing in and being
stored in the buffer, even when the <strong>Component</strong> responsible for processing them is not ready.
In order to make this happen, the "Input Stream Buffer" must be responsible for constantly
requesting the <strong>Driver</strong> to perform asynchronous read while providing space where these characters are going to be stored.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Start data accumulation in the internal buffer.</span>
    <span class="kt">void</span> <span class="n">start</span><span class="p">();</span>

    <span class="c1">// Stop data accumulation in the internal buffer.</span>
    <span class="kt">void</span> <span class="n">stop</span><span class="p">();</span>

    <span class="c1">// Inquire whether characters are being accumulated.</span>
    <span class="kt">bool</span> <span class="n">isRunning</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the times the responsible <strong>Component</strong> will require some number of characters to be accumulated before
their processing can be started. There is a need to provide asynchronous notification callback request
when appropriate number of characters becomes available. The callback must be stored in the internal
data structures of the "Input Stream Buffer" and invoked when needed. Due to the latter being developed
as a generic class, there is a need to provide callback storage type as a template parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWaitHandler</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncWaitDataAvailable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">reqSize</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">callback_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TWaitHandler</span> <span class="n">callback_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the required number of characters is accumulated, the <strong>Component</strong> must be able to access and process them.
It means that "Input Stream Buffer" must also be a container with random access iterators.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWaitHandler</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ConstIterator</span> <span class="n">ConstIterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">ConstIterator</span> <span class="n">const_iterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ValueType</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">ValueType</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">ConstReference</span> <span class="n">ConstReference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">ConstReference</span> <span class="n">const_reference</span><span class="p">;</span>

    <span class="c1">// Get size of available for read data.</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Check whether number of available characters is 0.</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//Get full capacity of the buffer.</span>
    <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">fullCapacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">ConstIterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstIterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstIterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstIterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ConstReference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that all the access to the characters are done using const iterator. It means we do not
allow external and uncontrolled update of the characters inside of the buffer.</p>
</div>
<div class="paragraph">
<p>When the characters inside the buffer got processed and aren&#8217;t needed any more, they need to be
discarded to free the space inside the buffer for new ones to come.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TBufSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWaitHandler</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InStreamBuf</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Consume part or the whole buffer of the available data for read.</span>
    <span class="kt">void</span> <span class="n">consume</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">consumeSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">());</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_morse_code_application">Morse Code Application</h4>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_morse">app_uart1_morse</a>
application in <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project implements buffering
of incoming characters in the "Input Stream Buffer" and uses the
<a href="http://en.wikipedia.org/wiki/Morse_code">Morse Code</a> method to display them by flashing the on-board led.</p>
</div>
<div class="paragraph">
<p>First of all there is a need to have an access to the led to flash, input buffer to store the incoming
characters and timer manager to allocate a timer to measure timeouts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TLed</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TInBuf</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TTimerMgr</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Morse</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">TLed</span> <span class="n">Led</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">TInBuf</span> <span class="n">InBuf</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">TTimerMgr</span> <span class="n">TimerMgr</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TimerMgr</span><span class="o">::</span><span class="n">Timer</span> <span class="n">Timer</span><span class="p">;</span>

    <span class="n">Morse</span><span class="p">(</span><span class="n">Led</span><span class="o">&amp;</span> <span class="n">led</span><span class="p">,</span> <span class="n">InBuf</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="n">TimerMgr</span><span class="o">&amp;</span> <span class="n">timerMgr</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">led_</span><span class="p">(</span><span class="n">led</span><span class="p">),</span>
        <span class="n">buf_</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
        <span class="n">timer_</span><span class="p">(</span><span class="n">timerMgr</span><span class="p">.</span><span class="n">allocTimer</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="n">timer_</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">Morse</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">Led</span><span class="o">&amp;</span> <span class="n">led_</span><span class="p">;</span>
    <span class="n">InBuf</span><span class="o">&amp;</span> <span class="n">buf_</span><span class="p">;</span>
    <span class="n">Timer</span> <span class="n">timer_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, there is a need to define a Morse code sequences in terms of dots and dashes duration as well as
mapping an incoming character to the respective sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Morse</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">InBuf</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">Duration</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Dot</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Dash</span> <span class="o">=</span> <span class="n">Dot</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">End</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Spacing</span> <span class="o">=</span> <span class="n">Dot</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">InterSpacing</span> <span class="o">=</span> <span class="n">Spacing</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">Duration</span><span class="o">*</span> <span class="n">getLettersSeq</span><span class="p">(</span><span class="n">CharType</span> <span class="n">ch</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_A</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Dot</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_B</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Dash</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>
        <span class="p">...</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_Z</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>

        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_0</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Dot</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>
        <span class="p">...</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span> <span class="n">Seq_9</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dash</span><span class="p">,</span> <span class="n">Dot</span><span class="p">,</span> <span class="n">End</span><span class="p">};</span>

        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span><span class="o">*</span> <span class="n">Letters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Seq_A</span><span class="p">,</span>
            <span class="n">Seq_B</span><span class="p">,</span>
            <span class="p">...</span>
            <span class="n">Seq_Z</span>
        <span class="p">};</span>

        <span class="k">static</span> <span class="k">const</span> <span class="n">Duration</span><span class="o">*</span> <span class="n">Numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Seq_0</span><span class="p">,</span>
            <span class="p">...</span>
            <span class="n">Seq_9</span>
        <span class="p">};</span>


        <span class="k">if</span> <span class="p">((</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'A'</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ch</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Letters</span><span class="p">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'a'</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ch</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'z'</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Letters</span><span class="p">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ch</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'9'</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Numbers</span><span class="p">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, the code that is responsible to flash a led is quite simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Morse</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">void</span> <span class="n">start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">buf_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
        <span class="n">nextLetter</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">nextLetter</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">buf_</span><span class="p">.</span><span class="n">asyncWaitDataAvailable</span><span class="p">(</span>
            <span class="mi">1U</span><span class="p">,</span>
            <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">es</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">GASSERT</span><span class="p">(</span><span class="n">buf_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
                    <span class="n">nextLetter</span><span class="p">();</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">buf_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
                <span class="k">auto</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">buf_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">buf_</span><span class="p">.</span><span class="n">consume</span><span class="p">(</span><span class="mi">1U</span><span class="p">);</span>

                <span class="k">auto</span><span class="o">*</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">getLettersSeq</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">nextLetter</span><span class="p">();</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">nextSyllable</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">nextSyllable</span><span class="p">(</span><span class="k">const</span> <span class="n">Duration</span><span class="o">*</span> <span class="n">seq</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
        <span class="n">GASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">End</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
        <span class="o">++</span><span class="n">seq</span><span class="p">;</span>

        <span class="n">led_</span><span class="p">.</span><span class="n">on</span><span class="p">();</span>
        <span class="n">timer_</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">duration</span><span class="p">),</span>
            <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">seq</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
                <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>

                <span class="n">led_</span><span class="p">.</span><span class="n">off</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">End</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">timer_</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="n">Spacing</span><span class="p">)),</span>
                        <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">seq</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
                            <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>
                            <span class="n">nextSyllable</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
                        <span class="p">});</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">timer_</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="n">InterSpacing</span><span class="p">)),</span>
                    <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
                        <span class="n">GASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">es</span><span class="p">);</span>
                        <span class="n">nextLetter</span><span class="p">();</span>
                    <span class="p">});</span>
            <span class="p">});</span>
    <span class="p">}</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>nextLetter()</code> member function waits until one character becomes available in the buffer,
then maps it to the sequence and removes it from the buffer. If the mapping exists it calls the
<code>nextSyllable()</code> member function to start the flashing sequence. The function activates the led
and waits the relevant amount of time, based on the provided dot or dash duration. After the
timeout, the led goes off and new wait is activated. However if the end of sequence is reached,
the wait will be of <code>InterSpacing</code> duration and <code>nextLetter()</code> member function will be called again,
otherwise the wait will be of <code>Spacing</code> duration and <code>nextSyllable()</code> will be called again to activate
the led and wait for the next period in the sequence.</p>
</div>
</div>
<div class="sect3">
<h4 id="_summary">Summary</h4>
<div class="paragraph">
<p>After this quite a significant effort we&#8217;ve created a full generic stack to perform asynchronous
input/output operations over serial interface, such as UART. It may be reused in multiple independent
projects while providing platform specific low level device control object at the bottom of this stack.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gpio">GPIO</h3>
<div class="paragraph">
<p>In many cases, the GPIO input doesn&#8217;t need to be processed at the same time the interrupt has occured.
It can easilily be scheduled for execution in event loop (non-interrupt) context
using <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model.</p>
</div>
<div class="paragraph">
<p>According to what was written in <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> chapter and to what we&#8217;ve
seen so far, the <strong>Component</strong> provides a callback object together with the asynchronous operation
request. The callback is executed only <strong>once</strong> when the operation is compete, canceled or terminated
due to some error. If the operation needs to be repeated, another asynchronous operation needs to be
issued to the <strong>Driver</strong> while providing another callback object to be called on operation completion.</p>
</div>
<div class="paragraph">
<p>The need for GPIO input handling is a bit different though. The line may change its value multiple
times between the reporting of the event to the <strong>Component</strong> and the latter re-requesting asynchronous
wait on value change. The <strong>Driver</strong> must preserve the callback object, provided by the <strong>Component</strong>,
and invoke it every time the GPIO input value changes until the <strong>Component</strong> cancels the operation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s go through all the stages in more detail.</p>
</div>
<div class="sect3">
<h4 id="_configuration">Configuration</h4>
<div class="imageblock">
<div class="content">
<img src="images/gpio_config.png" alt="Image: GPIO register handler">
</div>
</div>
<div class="paragraph">
<p>The <strong>Device</strong> must provide a callback object to handle GPIO interrupts on all the requested input lines.</p>
</div>
<div class="paragraph">
<p>The hardware must also be configured properly: input/output lines, the interrupts on the rising/falling
edges, etc.
Such configuration is platform/product specific and is not part of the generic
<a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model presented in this book. Hence, the product
specific <strong>Component</strong> must get an access to the device object and configure it as needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_start_continuous_asynchronous_read_operation">Start Continuous Asynchronous Read Operation</h4>
<div class="paragraph">
<p>The <strong>Driver</strong> must be able to support multiple asynchronous read operations on different inputs.
It means that it must protect an access to the internal data structures by requesting the <strong>Device</strong>
to suspend the callback invocation (i.e. disable interrupts). Also to follow the pattern we used so far,
there must be a request to start or enable the <strong>Device</strong>'s operation on the first read request and
cancel or disable it on the last.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gpio_read.png" alt="Image: GPIO read">
</div>
</div>
<div class="paragraph">
<p>The reader may notice that on the first <code>asyncReadCont()</code> request, the <strong>Driver</strong> issued
<code>suspend()</code> request to the <strong>Device</strong> and got <code>false</code> in return. It means that the <strong>Device</strong>'s
monitoring of the GPIO inputs hasn&#8217;t been started yet. That&#8217;s the reason for the following call to
<code>enable()</code>. On the second <code>asyncReadCont()</code> request the call to <code>suspend()</code> returned true which was
followed by the <code>resume()</code> later.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reporting_gpio_input_event">Reporting GPIO Input Event</h4>
<div class="paragraph">
<p>Now, every time the relevant GPIO interrupt occurs, the <strong>Driver</strong>'s handler is invoked in interrupt
mode context. It is responsible to schedule the execution of <strong>Component</strong>'s handler in event loop
(non-interrupt) context.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gpio_int_report.png" alt="Image: GPIO interrupt report">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancel_continuous_read_operation">Cancel Continuous Read Operation</h4>
<div class="paragraph">
<p>When the there is no need to monitor some input any more, the <strong>Component</strong> may request the
<strong>Driver</strong> to cancel the continuous asynchronous read operation. In case of last recorded
asynchronous read operation being canceled, the <strong>Driver</strong> is responsible to let the <strong>Device</strong>
know that no more GPIO interrupts are needed:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gpio_cancel.png" alt="Image: GPIO cancel read">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gpio_device">GPIO Device</h4>
<div class="paragraph">
<p>Based on the information above, the platform specific GPIO control <strong>Device</strong> object must
provide the following public interface:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define pin identification type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">PinIdType</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to provide a callback object to be called when interrupt occurs. The callback parameters
must provide an information of pin as well as final input value that caused the interrupt. The callback
object must implement the following signature: "void (PinIdType, bool)" where the first parameter is
pin and second parameter is input value.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">setHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to start / enable the GPIO input monitoring.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">start</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to cancel / disable the GPIO input monitoring.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">cancel</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to enable/disable gpio interrupts for single pin.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">setEnabled</span><span class="p">(</span>
    <span class="n">PinIdType</span> <span class="n">pin</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">enabled</span><span class="p">,</span>
    <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to suspend invocation of callback in interrupt mode, i.e. disable gpio interrupts.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">suspend</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>Function to resume suspended invocation of callback in interrupt mode, i.e. enable gpio interrupts.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">resume</span><span class="p">(</span><span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">context</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Such GPIO control <strong>Device</strong> class for RaspberryPi platform is implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Gpio.h">src/device/Gpio.h</a> file of
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gpio_driver">GPIO Driver</h4>
<div class="paragraph">
<p>First of all, we will need references to <strong>Device</strong> as well as <a href="#basic_concepts-event_loop">Event Loop</a> objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyGpioDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// During the construction store references to Device</span>
    <span class="c1">// and Event Loop objects.</span>
    <span class="n">MyGpioDriver</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
        <span class="n">el_</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Register appropriate interrupt callbacks with device</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setHandler</span><span class="p">(...);</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>

    <span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device_</span><span class="p">;</span>
    <span class="n">TEventLoop</span><span class="o">&amp;</span> <span class="n">el_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> must also provide an ability to perform and cancel continuous asynchronous read
operations for multiple pins:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TEventLoop</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyGpioDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">PinIdType</span> <span class="n">PinIdType</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncReadCont</span><span class="p">(</span><span class="n">PinIdType</span> <span class="n">id</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">cancelReadCont</span><span class="p">(</span><span class="n">PinIdType</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with any asynchronous operation so far the callback must receive status information as its
first parameter and probably the value of the input as the second one. When the operation canceled
with <code>cancelReadCont()</code>, the callback must be invoked one last time with status specifying that
operation was <code>Aborted</code>.</p>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> is supposed to be a generic piece of code that can be reused in multiple independent
products, including ones without dynamic memory allocation and/or exceptions. It means that the
<strong>Driver</strong> class must receive maximum number of the pins it is going to support and type of the
callback storage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TEventLoop</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TNumOfLines</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">THandler</span> <span class="o">=</span>
              <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyGpioDriver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">asyncReadCont</span><span class="p">(</span><span class="n">PinIdType</span> <span class="n">id</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// Locate or allocate appropriate node</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">id_</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">handler_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">Node</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="p">()</span> <span class="o">:</span> <span class="n">id_</span><span class="p">(</span><span class="n">PinIdType</span><span class="p">())</span> <span class="p">{}</span>

        <span class="n">PinIdType</span> <span class="n">id_</span><span class="p">;</span>
        <span class="n">THandler</span> <span class="n">handler_</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span> <span class="n">TNumOfLines</span><span class="o">&gt;</span> <span class="n">Infos</span><span class="p">;</span>

    <span class="n">Infos</span> <span class="n">infos_</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Driver</strong> doesn&#8217;t do anything special, it just receives the notification from the <strong>Device</strong>
that gpio interrupt has occurred, locates the appropriate registered <strong>Component</strong>'s callback
object (based on the pin information provided by the <strong>Device</strong>), and uses <strong>Event Loop</strong> to
schedule an execution of the <strong>Component</strong>'s callback together with information about input&#8217;s
value in event loop (non-interrupt) context.</p>
</div>
<div class="paragraph">
<p>Such generic GPIO <strong>Driver</strong> is already implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/driver/Gpio.h">embxx/driver/Gpio.h</a> file of
<a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect3">
<h4 id="_button_component">Button Component</h4>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project has a simple button <strong>Component</strong>,
implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/component/Button.h">src/component/Button.h</a>.
It configures provided GPIO line to be an input and to have both rising and falling edges interrupts.
It also exposes simple interface to be able to monitor button presses and releases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDriver</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">TActiveState</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">THandler</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Button</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">TDriver</span> <span class="n">Driver</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Driver</span><span class="o">::</span><span class="n">PinIdType</span> <span class="n">PinIdType</span><span class="p">;</span>

    <span class="n">Button</span><span class="p">(</span><span class="n">Driver</span><span class="o">&amp;</span> <span class="n">driver</span><span class="p">,</span> <span class="n">PinIdType</span> <span class="n">pin</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Button</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="n">isPressed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setPressedHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setReleasedHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_button_press_monitoring_application">Button Press Monitoring Application</h4>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project also contains a simple application
called <a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_button">app_button</a>. It monitors presses
and releases of a single button connected to one of the GPIO lines. When the button is pressed, the led is turned
on for 1 second and "Button Pressed" string is logged to UART. When the button is released, just
"Button Released" string is logged to UART without influencing the led state. If new button press is
recognised prior to 1 second timeout for the led being on, the led stays on and a new 1 second
timer countdown is started.</p>
</div>
<div class="paragraph">
<p>Thanks to the <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model and all levels of abstractions,
the application code is quite simple.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>

    <span class="c1">// Configure uart</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">uart</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">uart</span><span class="p">();</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">configBaud</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
    <span class="n">uart</span><span class="p">.</span><span class="n">setWriteEnabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Allocate timer</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">timerMgr</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">timerMgr</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">timerMgr</span><span class="p">.</span><span class="n">allocTimer</span><span class="p">();</span>
    <span class="n">GASSERT</span><span class="p">(</span><span class="n">timer</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>

    <span class="c1">// Set handlers for button press / release</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">button</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">button</span><span class="p">();</span>
    <span class="n">button</span><span class="p">.</span><span class="n">setPressedHandler</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">buttonPressed</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">timer</span><span class="p">)));</span>

    <span class="n">button</span><span class="p">.</span><span class="n">setReleasedHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buttonReleased</span><span class="p">);</span>

    <span class="c1">// Run event loop with enabled interrupts</span>
    <span class="n">device</span><span class="o">::</span><span class="n">interrupt</span><span class="o">::</span><span class="n">enable</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">eventLoop</span><span class="p">();</span>
    <span class="n">el</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

    <span class="n">GASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Mustn't exit</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for "button pressed" is as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">buttonPressed</span><span class="p">(</span><span class="n">System</span><span class="o">::</span><span class="n">TimerMgr</span><span class="o">::</span><span class="n">Timer</span><span class="o">&amp;</span> <span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">el</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">eventLoop</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">led</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">led</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">log</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>

    <span class="n">SLOG</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">,</span> <span class="s">"Button Pressed"</span><span class="p">);</span>

    <span class="n">timer</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">el</span><span class="p">.</span><span class="n">post</span><span class="p">(</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">led</span><span class="p">]()</span>
        <span class="p">{</span>
            <span class="n">led</span><span class="p">.</span><span class="n">on</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="n">GASSERT</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">WaitTime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">timer</span><span class="p">.</span><span class="n">asyncWait</span><span class="p">(</span>
        <span class="n">WaitTime</span><span class="p">,</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">led</span><span class="p">](</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">Aborted</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">led</span><span class="p">.</span><span class="n">off</span><span class="p">();</span>
        <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for "button release" is very simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">buttonReleased</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">system</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">log</span> <span class="o">=</span> <span class="n">system</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>

    <span class="n">SLOG</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">Info</span><span class="p">,</span> <span class="s">"Button Released"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peripherals-i2c">I2C</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> is serial communication bus. It is very popular in embedded
development and mostly used to communicate to various low speed peripherals, such as eeproms and
various sensors.</p>
</div>
<div class="paragraph">
<p>The control and use of I2C fits nicely into the <a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model described
in this book. It is a serial interface and the controlling <strong>Device</strong> object will have to read/write
characters one by one, just like it was with <a href="#peripherals-uart">UART</a>. It would be nice if we coud reuse the
Character <strong>Driver</strong> we implemented before. However, the I2C is multi-master / multi-slave bus and
there is a need to specify the slave ID (or address) when initiating read and/or write operation.</p>
</div>
<div class="sect3">
<h4 id="peripherals-i2c-id_adaptor">ID Adaptor</h4>
<div class="paragraph">
<p>It is quite clear that some kind of <strong>ID Device Adaptor</strong> is needed. It will be constructed with
additional ID parameter and will be responsible to forward all the API calls from the Character
<strong>Driver</strong> to I2C <strong>Device</strong> while adding one extra parameter of ID.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/id_adapter_write.png" alt="Image: Using ID Adapter">
</div>
</div>
<div class="paragraph">
<p>The implementation of such adaptor is very simple and straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IdAdaptor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the underlaying device.</span>
    <span class="k">typedef</span> <span class="n">TDevice</span> <span class="n">Device</span><span class="p">;</span>

    <span class="c1">// Character type defined in the wrapped device</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">CharType</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="c1">// Device identification type defined in the wrapped device class.</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">DeviceIdType</span> <span class="n">DeviceIdType</span><span class="p">;</span>

    <span class="n">IdAdaptor</span><span class="p">(</span><span class="n">Device</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">,</span> <span class="n">DeviceIdType</span> <span class="n">id</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">device_</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
        <span class="n">id_</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanReadHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setCanReadHandler</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanWriteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setCanWriteHandler</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setReadCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setReadCompleteHandler</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setWriteCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">setWriteCompleteHandler</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">startRead</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">cancelRead</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">startWrite</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">cancelWrite</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">suspend</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">suspend</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">resume</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">canRead</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">canRead</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">canWrite</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">canWrite</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="n">CharType</span> <span class="n">read</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Device</span><span class="o">&amp;</span> <span class="n">device_</span><span class="p">;</span>
    <span class="n">DeviceIdType</span> <span class="n">id_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The same adaptor class is implemented in
<a href="https://github.com/arobenko/embxx/blob/master/embxx/device/IdDeviceCharAdapter.h">embxx/device/IdDeviceCharAdapter.h</a>
file of <a href="https://github.com/arobenko/embxx">embxx</a> library.</p>
</div>
</div>
<div class="sect3">
<h4 id="peripheral-i2c-operations_queue">Operations Queue</h4>
<div class="paragraph">
<p>The I2C protocol allows existence of multiple independent slaves on the same bus. It means there may be
several independent <strong>Components</strong> that communicate to different I2C devices (for example EEPROM and
temperature sensor), but must share the same <strong>Device</strong> control object and may issue read/write requests
to it in parallel. To resolve this problem, there must be some kind of operation queuing facility that
is responsible to queue all the read/write requests to the <strong>Device</strong> and issue them one by one.</p>
</div>
<div class="paragraph">
<p>The objects' usage map looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/op_queue.png" alt="Image: Using Op Queue">
</div>
</div>
<div class="paragraph">
<p>Such queue is a platform/product independent piece of code and it should be implemented without using
dynamic memory allocation and/or exceptions. It means that it should receive number of various <strong>Driver</strong>
objects, that may issue independent read/write requests to it (i.e. size of the internal queue),
as a template parameter and probably use <a href="#basic_needs-queue">Static (Fixed Size) Queue</a> to queue all the requests that are coming
in. It should also receive callback storage types to report when a new character can be read/written,
as well as when read/write operation is complete.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TCanDoOpHandler</span> <span class="o">=</span> <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">TOpCompleteHandler</span> <span class="o">=</span>
              <span class="n">embxx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticFunction</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">embxx</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DeviceOpQueue</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DeviceOpQueue</span><span class="p">(</span><span class="n">TDevice</span><span class="o">&amp;</span> <span class="n">device</span><span class="p">);</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">container</span><span class="o">::</span><span class="n">StaticQueue</span><span class="o">&lt;</span><span class="p">...,</span> <span class="n">TSize</span><span class="o">&gt;</span> <span class="n">Queue</span><span class="p">;</span>
    <span class="n">Queue</span> <span class="n">queue_</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>TSize</code> template parameter is set to <code>1</code>, there is no need for all the queuing facility
and the <code>DeviceOpQueue</code> class may become a simple pass-through inline class using template specialisation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDevice</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DeviceOpQueue</span><span class="o">&lt;</span><span class="n">TDevice</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">TDevice</span><span class="o">::</span><span class="n">PinIdType</span> <span class="n">PinIdType</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">device_</span><span class="p">.</span><span class="n">startRead</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">PinIdType</span> <span class="n">id</span><span class="p">,</span> <span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// No use for id in the Device itself</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">cancelRead</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TArgs</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">suspend</span><span class="p">(</span><span class="n">PinIdType</span> <span class="n">id</span><span class="p">,</span> <span class="n">TArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// No use for id in the Device itself</span>
        <span class="k">return</span> <span class="n">device_</span><span class="p">.</span><span class="n">suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such queue is also implemented in <a href="https://github.com/arobenko/embxx">embxx</a> library. It resides in the
<a href="https://github.com/arobenko/embxx/blob/master/embxx/device/DeviceOpQueue.h">embxx/device/DeviceOpQueue.h</a> file.</p>
</div>
<div class="paragraph">
<p>Please note that <a href="#peripherals-i2c-id_adaptor">ID Adaptor</a> and <a href="#peripherals-i2c-operations_queue">[peripherals-i2c-operations_queue]</a> are both <strong>Device</strong>
layer classes. The serve as wrappers to actual peripheral control <strong>Device</strong> in order to expose the
right interface to the upper layer <strong>Driver</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_i2c_device">I2C Device</h4>
<div class="paragraph">
<p>The only thing that remains is to properly implement I2C control device, which can be used by the <code>DeviceOpQueue</code>,
which in turn is used by the <code>IdAdaptor</code>. The <code>IdAdaptor</code> object can be used with the existing <code>Character</code>
<strong>Driver</strong> implemented to be used with the <a href="#peripherals-uart">UART</a> peripheral.</p>
</div>
<div class="paragraph">
<p>Based on the information above, the platform specific I2C control <strong>Device</strong> object must provide the
following public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">I2CDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Single character type</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="c1">// ID type</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">DeviceIdType</span><span class="p">;</span>

    <span class="c1">// Context types</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopContext</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptContext</span><span class="p">;</span>

    <span class="c1">// Set various interrupt handlers</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanReadHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanWriteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setReadCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setWriteCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="c1">// Start read for both contexts.</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Cancel read for both contexts.</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Start write for both contexts.</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>
        <span class="n">TContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Cancel write for both contexts.</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Suspend/Resume</span>
    <span class="kt">bool</span> <span class="n">suspend</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">resume</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>

    <span class="c1">// Helper functions to manage read/write during the interrupt</span>
    <span class="kt">bool</span> <span class="n">canRead</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">canWrite</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="n">CharType</span> <span class="n">read</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">CharType</span> <span class="n">value</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such device to control <strong>I2C0</strong> interface on RaspberryPi platform is implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/I2C0.h">src/device/I2C0.h</a> file of
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eeprom_access_application">EEPROM Access Application</h4>
<div class="paragraph">
<p>The <a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project contains an application called
<a href="https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_i2c0_eeprom">app_i2c0_eeprom</a>. It
implements a parallel access to 2 EEPROMs connected to the same I2C0 bus, but having different addresses.
The EEPROMs are accessed independently at the same time with read/write operations. These operations are
queued and managed by the <code>DeviceOpQueue</code> object that wraps actual I2C control <strong>Device</strong> and forwards
the requests one by one.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peripherals-spi">SPI</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a> is also quite popular serial
communication interface. It is very similar to <a href="#peripherals-i2c">I2C</a> in terms of using it the
<a href="#basic_concepts-device_driver_component">Device-Driver-Component</a> model described in this book. The main differences are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SPI uses "chip select" identification method instead of "address" of the peripheral.</p>
</li>
<li>
<p>SPI is a double direction link - there are always read and write operations that are
executed in parallel (instead of only read or only write).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The "chip select" slave identefication will require the same "<strong>ID Adaptor</strong>" that was
used for <a href="#peripherals-i2c">I2C</a> integration.</p>
</div>
<div class="paragraph">
<p>Just like with <a href="#peripherals-i2c">I2C</a>, the <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>
is a multi-slave bus. It allows connection of multiple independent devices to the same MISO/MOSI/CLK
lines of the SPI interface. It means there is a need for the same "<strong>Operations Queue</strong>" that was used
for <a href="#peripherals-i2c">I2C</a> integration. Due to the fact that SPI is a double direction link, the
"<strong>Operations Queue</strong>" must be able to forward, say, read operation request to the actual <strong>Device</strong>
even if "write" operation to the same slave device is already in progress.</p>
</div>
<div class="paragraph">
<p>It means that the objects' usage map is exactly the same as with <a href="#peripherals-i2c">I2C</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/op_queue.png" alt="Image: Using Op Queue">
</div>
</div>
<div class="paragraph">
<p>All the intermediate layers (Character <strong>Driver</strong>, ID Adaptor, Operations Queue) in the map above must allow
issuing read and write operations at the same time. It becomes a responsibility of the product specific
<strong>Component</strong> to be aware what kind of the <strong>Device</strong> is used and not to issue these requests in parallel
if the actual <strong>Device</strong> (such as I2C) doesn&#8217;t support it.</p>
</div>
<div class="sect3">
<h4 id="_spi_device">SPI Device</h4>
<div class="paragraph">
<p>Based on the information above, the platform specific SPI control <strong>Device</strong> object must provide and
implement exactly the same interface as <a href="#peripherals-i2c">I2C</a> <strong>Device</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">class</span> <span class="nc">SpiDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Single character type</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">CharType</span><span class="p">;</span>

    <span class="c1">// ID type - chip select index</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">DeviceIdType</span><span class="p">;</span>

    <span class="c1">// Context types</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">EventLoop</span> <span class="n">EventLoopContext</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">embxx</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">context</span><span class="o">::</span><span class="n">Interrupt</span> <span class="n">InterruptContext</span><span class="p">;</span>

    <span class="c1">// Set various interrupt handlers</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanReadHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setCanWriteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setReadCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">setWriteCompleteHandler</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

    <span class="c1">// Start read for both contexts.</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">chipSelect</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">startRead</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">chipSelect</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Cancel read for both contexts.</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">cancelRead</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Start write for both contexts.</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">chipSelect</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">startWrite</span><span class="p">(</span><span class="n">DeviceIdType</span> <span class="n">chipSelect</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>
        <span class="n">TContext</span> <span class="n">context</span><span class="p">);</span>

    <span class="c1">// Cancel write for both contexts.</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">cancelWrite</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>

    <span class="c1">// Suspend/Resume</span>
    <span class="kt">bool</span> <span class="n">suspend</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">resume</span><span class="p">(</span><span class="n">EventLoopContext</span><span class="p">);</span>

    <span class="c1">// Helper functions to manage read/write during the interrupt</span>
    <span class="kt">bool</span> <span class="n">canRead</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">canWrite</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="n">CharType</span> <span class="n">read</span><span class="p">(</span><span class="n">InterruptContext</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">CharType</span> <span class="n">value</span><span class="p">,</span> <span class="n">InterruptContext</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such device to control <strong>SPI0</strong> interface on RaspberryPi platform is implemented in
<a href="https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Spi0.h">src/device/Spi0.h</a> file of
<a href="https://github.com/arobenko/embxx_on_rpi">embxx_on_rpi</a> project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_other_nuances">Other Nuances</h4>
<div class="paragraph">
<p>SPI is quite often used  with external persistent storage, such as SD card. Such devices may have some
significant delays between the block write operation on the <code>MOSI</code> line and the time they send an
acknowledgement about operation completion on the <code>MISO</code> line. The SPI <strong>Device</strong> must constantly read
the incoming bytes until the expected <code>ACK</code>/<code>NACK</code> byte is received without de-asserting the <code>CS</code>
(chip select). If the <strong>Component</strong>, responsible for managing SPI flash memory, issues only single
"read" operation to wait for such an acknowledgement, the provided buffer may get full before the
required byte is received. In this case the SPI control <strong>Device</strong> object is not aware that the new
"read" request may follow and has to de-assert the <code>CS</code>, which is undesireble.</p>
</div>
<div class="paragraph">
<p>In order to solve this problem, the Character <strong>Driver</strong> described in <a href="#peripherals-uart">UART</a> chapter must
be extended to support issuing multiple read/write operations at the same time. Such extension is
based on the values of <code>ReadQueueSize</code>/<code>WriteQueueSize</code> in the provided <code>Traits</code> class. These
values indicate maximal number of simultaneous read/write operations that may be issued to the
<strong>Driver</strong>. The responsible <strong>Component</strong>, in turn, must perform 2 or 3 "read until" operations at
the same time to wait for the expected response. Once the first buffer is full, the <strong>Driver</strong> will
post the <strong>Component</strong>'s callback object for execution in the event loop context, while calling
<code>startRead()</code> member function of the <strong>Device</strong> for the next pending "read until" operation still
in interrupt context to fill the second buffer. The <strong>Device</strong> is responsible to continue its read
operation without de-asserting the <code>CS</code> line. While the second buffer being filled, the <strong>Component</strong>
has enough time to identify that there is no response in the filled buffer and re-issue the "read until"
request to the <strong>Driver</strong> while reusing the same buffer. This circle of "read until" requests must
continue until expected response is encountered or until operation timeout, which is measured independently
by the asynchronous wait request to the [Timer](timer.md). It is up to the responsible <strong>Component</strong> object
to manage the operations to the Character <strong>Driver</strong> as well as the Timer in event loop context and cancel
one upon execution of callback from another.</p>
</div>
</div>
<div class="sect3">
<h4 id="_external_storage">External Storage</h4>
<div class="paragraph">
<p>As was mentioned in previous section, SPI is often used with external persistent storage, such as
SD card. In order to properly support it, there must be some kind of <code>SpiFlash</code> management <strong>Component</strong>,
that is responsible to implement proper
<a href="https://www.sdcard.org/downloads/pls/simplified_specs/part1_410.pdf">communication protocol</a> while
providing necessary public interface. The minimal required interface will have to be able to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Asynchronously initialise the device.</p>
</li>
<li>
<p>Asynchronously read block of data.</p>
</li>
<li>
<p>Asynchronously write block of data.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once such <strong>Component</strong> is implemented and tested, the next stage would be implementing proper file
system (FAT32) management <strong>Component</strong>, using the asynchronous functions of the former. It will allow
processing time consuming file system reads and writes while still allowing processing of all other
events without creating any performance bottlenecks and without requiring any complex independent
task scheduling.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other">Other</h3>
<div class="paragraph">
<p>There are many other peripherals and/or protocols (such as I2S, USB, one wire). The implementation
and the main concepts should be pretty similar to the peripherals covered so far. At this stage I
do not plan to do it in this book. At least not in the near future.</p>
</div>
<div class="paragraph">
<p>Various micro-controllers may also support <a href="http://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> access
to some peripherals. In this case the <code>Character</code> <strong>Driver</strong> that was covered in <a href="#peripherals-uart">UART</a>
chapter must be replaced with some kind of <code>Block</code> <strong>Driver</strong>, that will allow issuing of multiple
read/write requests at the same time and will receive only "operation complete" notifications from
the <strong>Device</strong>. I leave implementation of it as an excercise for the reader. At least for now.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2021-02-12 17:54:30 +1000
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</body>
</html>